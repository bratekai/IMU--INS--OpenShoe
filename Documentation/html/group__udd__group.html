<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenShoe: USB Device Driver (UDD)</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenShoe
   &#160;<span id="projectnumber">0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">USB Device Driver (UDD)</div>  </div>
<div class="ingroups"><a class="el" href="group__usb__device__group.html">USB Stack Devices</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudd__setup__req__t.html">udd_setup_req_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudd__ctrl__request__t.html">udd_ctrl_request_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Global variable to give and record information of the setup request management.  <a href="structudd__ctrl__request__t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaffd9b7cf165cd149868373fa12595d12">Udd_setup_is_in</a>()&#160;&#160;&#160;(USB_REQ_DIR_IN == (udd_g_ctrlreq.req.bmRequestType &amp; USB_REQ_DIR_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the setup request <em>udd_g_ctrlreq</em> indicates IN data transfer.  <a href="#gaffd9b7cf165cd149868373fa12595d12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf67b7c8de30fdc881b567385f2345926">Udd_setup_is_out</a>()&#160;&#160;&#160;(USB_REQ_DIR_OUT == (udd_g_ctrlreq.req.bmRequestType &amp; USB_REQ_DIR_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the setup request <em>udd_g_ctrlreq</em> indicates OUT data transfer.  <a href="#gaf67b7c8de30fdc881b567385f2345926"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga85dc2b7b6c270e8dd8323fa4779a7ca2">Udd_setup_type</a>()&#160;&#160;&#160;(udd_g_ctrlreq.req.bmRequestType &amp; USB_REQ_TYPE_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the SETUP request <em>udd_g_ctrlreq</em>.  <a href="#ga85dc2b7b6c270e8dd8323fa4779a7ca2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gac963bb7b8a965c2fec45a71c9faca6f5">Udd_setup_recipient</a>()&#160;&#160;&#160;(udd_g_ctrlreq.req.bmRequestType &amp; USB_REQ_RECIP_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the recipient of the SETUP request <em>udd_g_ctrlreq</em>.  <a href="#gac963bb7b8a965c2fec45a71c9faca6f5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6f25ea016c07bd48c3074f51d8ef8b01">udd_ep_id_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint identifier.  <a href="#ga6f25ea016c07bd48c3074f51d8ef8b01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga7ab8d43f0761ecfb4d48770ac4ebb661">udd_callback_halt_cleared_t</a> )(void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">End of halt callback function type. Registered by routine udd_ep_wait_stall_clear() Callback called when endpoint stall is cleared.  <a href="#ga7ab8d43f0761ecfb4d48770ac4ebb661"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad866ed9444482edcf92a28dce807e3d3">udd_callback_trans_t</a> )(<a class="el" href="group__udd__group.html#gac0f77f5a0e085af1242b48fd1054959a">udd_ep_status_t</a> status, iram_size_t nb_transfered)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">End of transfer callback function type. Registered by routine udd_ep_run() Callback called by USB interrupt after data transfer or abort (reset,...).  <a href="#gad866ed9444482edcf92a28dce807e3d3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gac0f77f5a0e085af1242b48fd1054959a">udd_ep_status_t</a> { <a class="el" href="group__udd__group.html#ggac0f77f5a0e085af1242b48fd1054959aad52bb23180c67dc3d6a1d1dfedf74102">UDD_EP_TRANSFER_OK</a> =  0, 
<a class="el" href="group__udd__group.html#ggac0f77f5a0e085af1242b48fd1054959aa010443246cb439e4f6f52b13c9d6e29c">UDD_EP_TRANSFER_ABORT</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint transfer status Returned in parameters of callback register via udd_ep_run routine.  <a href="group__udd__group.html#gac0f77f5a0e085af1242b48fd1054959a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga14096700b3ed8c5168615c5c5ee1c68d">COMPILER_PACK_SET</a> (1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB Device SETUP request.  <a href="#ga14096700b3ed8c5168615c5c5ee1c68d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gabe317a1520896eaf568afab27dc71540">COMPILER_PACK_RESET</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structudd__ctrl__request__t.html">udd_ctrl_request_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga360872da67c7f8ecebe1238bbd4a536e">udd_g_ctrlreq</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Global variable to give and record information about setup request management.  <a href="#ga360872da67c7f8ecebe1238bbd4a536e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Power management routine.</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf5ca2932775dabb853197df18706c469">USBC_SLEEP_MODE_USB_SUSPEND</a>&#160;&#160;&#160;SLEEPMGR_STATIC</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of sleep levels.  <a href="#gaf5ca2932775dabb853197df18706c469"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga90aeabbf00db4be8f0a1feef5cf0bbb3">USBC_SLEEP_MODE_USB_IDLE</a>&#160;&#160;&#160;SLEEPMGR_IDLE</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Control endpoint low level management routine.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc60f904f933dd5c177261b92bc2abc62"></a> This function performs control endpoint mangement. It handle the SETUP/DATA/HANDSHAKE phases of a control transaction. </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gabc925782d47feeb37f6f943579038b84">udd_ctrl_ep_state_t</a> { <br/>
&#160;&#160;<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84a2357a1ac77f59da70848f4121a016e77">UDD_EPCTRL_SETUP</a> =  0, 
<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84acf3cc280a0061ecf321e0191d37dc53c">UDD_EPCTRL_DATA_OUT</a> =  1, 
<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84a57e63cb5de1f85c276dbfa8c3c00deed">UDD_EPCTRL_DATA_IN</a> =  2, 
<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84aadbf4f42e07b8589262e727b3cf8b900">UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84ae5dd6cabf3ebb1aab6a80d7a92a89513">UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP</a> =  4, 
<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84a8d44562cd9ac18661adcf35015f8972e">UDD_EPCTRL_STALL_REQ</a> =  5
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit definitions about endpoint control state machine for udd_ep_control_state.  <a href="group__udd__group.html#gabc925782d47feeb37f6f943579038b84">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">COMPILER_WORD_ALIGNED <br class="typebreak"/>
<a class="el" href="structudd__ctrl__request__t.html">udd_ctrl_request_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga2a41c2b14c5be825bdce7fde8c365a30">udd_g_ctrlreq</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Global variable to give and record information about setup request management.  <a href="#ga2a41c2b14c5be825bdce7fde8c365a30"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Management of bulk/interrupt/isochronous endpoints</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpeb26be1d47656a473f2b25d5d9510dc8"></a>Buffer to store the data received on control endpoint (SETUP/OUT endpoint 0)</p>
<p>Used to avoid a RAM buffer overflow in case of the payload buffer is smaller than control endpoint size</p>
<p>The UDD manages the data transfer on endpoints:</p>
<ul>
<li>Start data tranfer on endpoint with USB Device DMA</li>
<li>Send a ZLP packet if requested</li>
<li>Call callback registered to signal end of transfer The transfer abort and stall feature are supported. </li>
</ul>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaa4cac8c35ae056e26cf4ab5b426bbe09">udd_include_vbus_monitoring</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Authorizes the VBUS event.  <a href="#gaa4cac8c35ae056e26cf4ab5b426bbe09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga9792d1899ae058e3984d6a622fe2ad42">udd_enable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the USB Device mode.  <a href="#ga9792d1899ae058e3984d6a622fe2ad42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gab283432057b934e9d73ac9282d9b0f11">udd_disable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the USB Device mode.  <a href="#gab283432057b934e9d73ac9282d9b0f11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga7a7c0d9236c922c2af33c6702565a99f">udd_attach</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach device to the bus when possible.  <a href="#ga7a7c0d9236c922c2af33c6702565a99f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga03e59eaa264f1dbe5a52559311d0520e">udd_detach</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the device from the bus.  <a href="#ga03e59eaa264f1dbe5a52559311d0520e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga85f403ddb78776b1ba014dafd3ffec2c">udd_is_high_speed</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the USB Device Controller is running at high speed or not.  <a href="#ga85f403ddb78776b1ba014dafd3ffec2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga05da762e0faf9d478e532de40afa71f6">udd_set_address</a> (uint8_t address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the USB address of device.  <a href="#ga05da762e0faf9d478e532de40afa71f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaebd36638d482f6df00a8aff006ef2246">udd_getaddress</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the USB address of device.  <a href="#gaebd36638d482f6df00a8aff006ef2246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga96dc248cc05e07ffe2cf21e4d7465320">udd_get_frame_number</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current start of frame number.  <a href="#ga96dc248cc05e07ffe2cf21e4d7465320"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga63047eec59b8e8798ca1d3366472d82b">udd_get_micro_frame_number</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current micro start of frame number.  <a href="#ga63047eec59b8e8798ca1d3366472d82b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga14ae6068206556d6ae8766b1baa2f686">udd_send_wake_up</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The USB driver sends a resume signal called Upstream Resume.  <a href="#ga14ae6068206556d6ae8766b1baa2f686"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga017ef5ea7626be258c24d345218976f9">udd_set_setup_payload</a> (uint8_t *payload, uint16_t payload_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load setup payload.  <a href="#ga017ef5ea7626be258c24d345218976f9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
USBC Device IP properties</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp55d0406ba5e21eb26b437407f55e3f47"></a> These macros give access to IP properties </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga4f3fc518ef0e369cc01a7bf7c6516844">UDD_get_endpoint_max_nbr</a>()&#160;&#160;&#160;(((Rd_bitfield(AVR32_USBC_ufeatures, AVR32_USBC_UFEATURES_EPT_NBR_MAX_MASK) - 1) &amp; ((1 &lt;&lt; AVR32_USBC_UFEATURES_EPT_NBR_MAX_SIZE) - 1)) + 1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal number of endpoints.  <a href="#ga4f3fc518ef0e369cc01a7bf7c6516844"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
USBC Device speeds management</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf272a0d4210ee260d0a267bba460fb0c">udd_low_speed_enable</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable device low-speed mode.  <a href="#gaf272a0d4210ee260d0a267bba460fb0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6471bbaea371bb9bb2654333236c9f29">udd_low_speed_disable</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaedea021600d07a71a1672b393c550c39">Is_udd_low_speed_enable</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if device low-speed mode is forced.  <a href="#gaedea021600d07a71a1672b393c550c39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gae014bb3adcdf212fd61196307be88802">udd_high_speed_enable</a>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga7adf42a2ec72e7f2429a9b02799333af">udd_high_speed_disable</a>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga977c78f164f32fa910802518aab7b0ed">Is_udd_full_speed_mode</a>()&#160;&#160;&#160;true</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
USBC Device vbus management</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf80c5f873a9d926ab3324b6a91dfd872">udd_enable_vbus_interrupt</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad11887e29c08ad9cc6d67e3e6b4f9e9a">udd_disable_vbus_interrupt</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaed8ac44b2b2082c1797e873e120867c8">Is_udd_vbus_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga10bc6d84d73e1ecccae3318d4098c41a">Is_udd_vbus_high</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUS_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6f962d911e1863d143614d1ee01df89a">Is_udd_vbus_low</a>()&#160;&#160;&#160;(!Is_udd_vbus_high())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gac6886b5956566ddb81744bbcfb27c08d">udd_ack_vbus_transition</a>()&#160;&#160;&#160;(AVR32_USBC.usbstaclr = AVR32_USBC_USBSTACLR_VBUSTIC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga8761342ea2dc32e0f0252508b1f7c47a">udd_raise_vbus_transition</a>()&#160;&#160;&#160;(AVR32_USBC.usbstaset = AVR32_USBC_USBSTASET_VBUSTIS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gafb6dd005e6fef2574f054b8fe5e8d008">Is_udd_vbus_transition</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUSTI_MASK))</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
USBC device attach control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0e11470ac1c73a71585f2d1aea6db499"></a> These macros manage the USBC Device attach. </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1863dacf593fb3c1b5f275b48f1e529a">udd_detach_device</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">detaches from USB bus  <a href="#ga1863dacf593fb3c1b5f275b48f1e529a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga55686d13fc7b23f4945f527f0dd15906">udd_attach_device</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">attaches to USB bus  <a href="#ga55686d13fc7b23f4945f527f0dd15906"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf8c45e04066c136079dd296c2e28bb62">Is_udd_detached</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">test if the device is detached  <a href="#gaf8c45e04066c136079dd296c2e28bb62"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
USBC device bus events control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8685ab0e6929620c4e0d67ee25ea7fa9"></a> These macros manage the USBC Device bus events. </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gacc4b62140d09930dd38b10f766d30517">udd_initiate_remote_wake_up</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf3dab5078ad3286ac92d7b3a8cf8933a">Is_udd_pending_remote_wake_up</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga0f538482266ca447cbfcfb9a5eb2bd64">udd_enable_remote_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_UPRSMES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad53f9dce1280a2b17218090cde573368">udd_disable_remote_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_UPRSMEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga2a4c5935ae7ae26e8edf63a27d3d30d9">Is_udd_remote_wake_up_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_UPRSME_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga39c4b005d3194988c8969ea622eed23d">udd_ack_remote_wake_up_start</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_UPRSMC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga8e9d45e299d7a26b65bf8a98c8e27546">udd_raise_remote_wake_up_start</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_UPRSMS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gacfe73866ea62b418fe69fa061ef6edd3">Is_udd_remote_wake_up_start</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_UPRSM_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad7f806ed3fbecb776acc5dcedcf81f3e">udd_enable_resume_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSMES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga8a97ab6519a34ae7d9135fe70c6719e4">udd_disable_resume_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSMEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga3cad513921d4190558aa7744d672bfc3">Is_udd_resume_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSME_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gabc25572243c4ab4600a1a870b4b6028b">udd_ack_resume</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSMC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga32a47c6752a2cac56874691e34728ba5">udd_raise_resume</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSMS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1b2ed8acdccb1fa2d295610349979fe5">Is_udd_resume</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORSM_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1b192f6b945ae10b536deca002c2a1aa">udd_enable_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_WAKEUPES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaeac784d6d727d949449042d979d9a2ff">udd_disable_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_WAKEUPEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaeab0126ceda728b5e100675a1368219a">Is_udd_wake_up_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_WAKEUPE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gadf64e48ecbcfc8082ac438156d43311d">udd_ack_wake_up</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_WAKEUPC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6b5a8ee09140c447b077c66c2e7668fe">udd_raise_wake_up</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_WAKEUPS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga27099aac5c46e62ca82775e957ae52a4">Is_udd_wake_up</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_WAKEUP_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaa4f338d7c02eb47691d55ea26a0b32d7">udd_enable_reset_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSTES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga4f19c394e2352deb16c13e15c34c59ff">udd_disable_reset_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSTEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gae0697533a9d3b806351a6a075100dd9f">Is_udd_reset_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSTE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gae28a4338a4679d081090a536f7bd3ee1">udd_ack_reset</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSTC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6c25f895374748a59eaa9a84356a5d58">udd_raise_reset</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSTS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga8bcb98dbb6f1255a0f25ae73035927db">Is_udd_reset</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORST_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga307066f7fb27b90020e50f7311b37ff6">udd_enable_sof_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SOFES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1210d31d31bcbcaf8374ac4db1521306">udd_disable_sof_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SOFEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gacc090cdf3bd05a4da6888695fd95786b">Is_udd_sof_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SOFE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga0b4140471f2e53d93cfe7f05ebd907d7">udd_ack_sof</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SOFC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga3747765066014e9bbde1bb263334c8a0">udd_raise_sof</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SOFS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga5b5fcaa7cfa64de404ff9a3a257839a9">Is_udd_sof</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SOF_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gac175ccc890008605691939957098a246">udd_frame_number</a>()&#160;&#160;&#160;(Rd_bitfield(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNUM_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6f519fdc7583b259eb11d33555813182">Is_udd_frame_number_crc_error</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNCERR_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga298cc43d16d7d9609d58adffe696b5db">udd_enable_suspend_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SUSPES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1470fba0dbc68e890140d806277ee8c1">udd_disable_suspend_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SUSPEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga2a9c882005f263ea9e181273bf316e27">Is_udd_suspend_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SUSPE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga9a61b0228571cf2c0225c86f3e3a618e">udd_ack_suspend</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SUSPC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga997d9f1f31efd62ddcce775a4f40a0bd">udd_raise_suspend</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SUSPS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gadfe9e8bbc2b3afefb19bcfd99db8b3fd">Is_udd_suspend</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SUSP_MASK))</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
High speed test mode management</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2db3720a79ccf99f281dc8b84ab95b6b"></a> The following functions allow the device to jump to a specific test mode required in high speed mode. </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga43ba1e91e69f84c1481a659ff8eff143">udd_test_mode_j</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga2acd547bcd2b470ee4e1ce34087926a8">udd_test_mode_k</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gabec7e8b6464e92ca9c8f32c59113bcbb">udd_test_mode_se0_nak</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gab72f68f8d1a50f7e734595a2ff626380">udd_test_mode_packet</a> (void)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
UDC callbacks to provide for UDD</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpac0b98f9d000f73c8d3a8c3cb0ebf40a"></a> The following callbacks are used by UDD. </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga58c2916d7984e0e5b2143cadf4af6080">udc_process_setup</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes and manages a setup request.  <a href="#ga58c2916d7984e0e5b2143cadf4af6080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga11a32ff7928ba06d3b59e95e0a2b7a92">udc_reset</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the UDC.  <a href="#ga11a32ff7928ba06d3b59e95e0a2b7a92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga4afae313045f44b5eb4c60957ab8ef4e">udc_sof_notify</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To signal that a SOF is occured.  <a href="#ga4afae313045f44b5eb4c60957ab8ef4e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" id="USBC_CONF"></a>
USBC Custom configuration</h2>
<p>The following USBC driver configuration must be included in the <a class="el" href="conf__usb_8h.html" title="USB configuration file for CDC application.">conf_usb.h</a> file of the application.</p>
<p>UDD_USB_INT_LEVEL<br/>
 Option to change the interrupt priority (0 to 3) by default 0 (recommended).</p>
<h2><a class="anchor" id="Callbacks"></a>
management</h2>
<p>The USB driver is fully managed by interrupt and does not request periodique task. Thereby, the USB events use callbacks to transfer the information. The callbacks are declared in static during compilation or in variable during code execution.</p>
<p>Static declarations defined in <a class="el" href="conf__usb_8h.html" title="USB configuration file for CDC application.">conf_usb.h</a>:</p>
<ul>
<li><a class="el" href="conf__usb_8h.html#a009dfd7822890bfe9a8975f14d952508">UDC_VBUS_EVENT(bool b_present)</a><br/>
 To signal Vbus level change</li>
<li>UDC_SUSPEND_EVENT()<br/>
 Called when USB bus enter in suspend mode</li>
<li>UDC_RESUME_EVENT()<br/>
 Called when USB bus is wakeup</li>
<li>UDC_SOF_EVENT()<br/>
 Called for each received SOF, Note: Each 1ms in HS/FS mode only.</li>
</ul>
<p>Dynamic callbacks, called "endpoint job" , are registered in udd_ep_job_t structure via the following functions:</p>
<ul>
<li>udd_ep_run()<br/>
 To call it when a transfer is finish</li>
<li>udd_ep_wait_stall_clear()<br/>
 To call it when a endpoint halt is disabled</li>
</ul>
<h2><a class="anchor" id="Power"></a>
mode management</h2>
<p>The Sleep modes authorized :</p>
<ul>
<li>in USB IDLE state, the USBC needs of USB clock and authorizes up to IDLE mode</li>
<li>in USB SUSPEND state, the USBC no needs USB clock but requests a minimum clock restart timing. Thus, it authorizes up to STATIC or STANDBY mode.</li>
<li>VBUS monitoring used in USB Self-Power mode authorizes up to STOP mode</li>
</ul>
<p>The USBC_SLEEP_MODE_USB_IDLE equals SLEEPMGR_IDLE.</p>
<p>The USBC_SLEEP_MODE_USB_SUSPEND depends on USB Power mode, USB clock startup timing and USB Speed mode: | Power Mode | Speed mode | Clock Startup | Sleep mode authorized | | X | LS, FS | &gt;10ms | SLEEPMGR_STDBY | | X | HS | &gt;3ms | SLEEPMGR_STDBY | | Self-Power | LS, FS | &lt;=10ms | SLEEPMGR_STOP | | Self-Power | HS | &lt;=3ms | SLEEPMGR_STOP | | Bus-Power | LS, FS | &lt;=10ms | SLEEPMGR_STATIC | | Bus-Power | HS | &lt;=3ms | SLEEPMGR_STATIC |</p>
<p>USBC low-level driver for USB Device mode</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Bit-masks are used instead of bit-fields because PB registers require 32-bit write accesses while AVR32-GCC 4.0.2 builds 8-bit accesses even when volatile unsigned int bit-fields are specified.</dd></dl>
<p>The UDD driver provides a low-level abstraction of the device controller hardware. Most events coming from the hardware such as interrupts, which may cause the UDD to call into the UDC and UDI. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaf8c45e04066c136079dd296c2e28bb62"></a><!-- doxytag: member="usbc_device.h::Is_udd_detached" ref="gaf8c45e04066c136079dd296c2e28bb62" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_detached</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test if the device is detached </p>

</div>
</div>
<a class="anchor" id="ga6f519fdc7583b259eb11d33555813182"></a><!-- doxytag: member="usbc_device.h::Is_udd_frame_number_crc_error" ref="ga6f519fdc7583b259eb11d33555813182" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_frame_number_crc_error</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNCERR_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga977c78f164f32fa910802518aab7b0ed"></a><!-- doxytag: member="usbc_device.h::Is_udd_full_speed_mode" ref="ga977c78f164f32fa910802518aab7b0ed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_full_speed_mode</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;true</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaedea021600d07a71a1672b393c550c39"></a><!-- doxytag: member="usbc_device.h::Is_udd_low_speed_enable" ref="gaedea021600d07a71a1672b393c550c39" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_low_speed_enable</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if device low-speed mode is forced. </p>

</div>
</div>
<a class="anchor" id="gaf3dab5078ad3286ac92d7b3a8cf8933a"></a><!-- doxytag: member="usbc_device.h::Is_udd_pending_remote_wake_up" ref="gaf3dab5078ad3286ac92d7b3a8cf8933a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_pending_remote_wake_up</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2a4c5935ae7ae26e8edf63a27d3d30d9"></a><!-- doxytag: member="usbc_device.h::Is_udd_remote_wake_up_interrupt_enabled" ref="ga2a4c5935ae7ae26e8edf63a27d3d30d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_remote_wake_up_interrupt_enabled</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_UPRSME_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacfe73866ea62b418fe69fa061ef6edd3"></a><!-- doxytag: member="usbc_device.h::Is_udd_remote_wake_up_start" ref="gacfe73866ea62b418fe69fa061ef6edd3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_remote_wake_up_start</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_UPRSM_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8bcb98dbb6f1255a0f25ae73035927db"></a><!-- doxytag: member="usbc_device.h::Is_udd_reset" ref="ga8bcb98dbb6f1255a0f25ae73035927db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_reset</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORST_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae0697533a9d3b806351a6a075100dd9f"></a><!-- doxytag: member="usbc_device.h::Is_udd_reset_interrupt_enabled" ref="gae0697533a9d3b806351a6a075100dd9f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_reset_interrupt_enabled</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSTE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1b2ed8acdccb1fa2d295610349979fe5"></a><!-- doxytag: member="usbc_device.h::Is_udd_resume" ref="ga1b2ed8acdccb1fa2d295610349979fe5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_resume</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORSM_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3cad513921d4190558aa7744d672bfc3"></a><!-- doxytag: member="usbc_device.h::Is_udd_resume_interrupt_enabled" ref="ga3cad513921d4190558aa7744d672bfc3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_resume_interrupt_enabled</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSME_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5b5fcaa7cfa64de404ff9a3a257839a9"></a><!-- doxytag: member="usbc_device.h::Is_udd_sof" ref="ga5b5fcaa7cfa64de404ff9a3a257839a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_sof</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SOF_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacc090cdf3bd05a4da6888695fd95786b"></a><!-- doxytag: member="usbc_device.h::Is_udd_sof_interrupt_enabled" ref="gacc090cdf3bd05a4da6888695fd95786b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_sof_interrupt_enabled</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SOFE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadfe9e8bbc2b3afefb19bcfd99db8b3fd"></a><!-- doxytag: member="usbc_device.h::Is_udd_suspend" ref="gadfe9e8bbc2b3afefb19bcfd99db8b3fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_suspend</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SUSP_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2a9c882005f263ea9e181273bf316e27"></a><!-- doxytag: member="usbc_device.h::Is_udd_suspend_interrupt_enabled" ref="ga2a9c882005f263ea9e181273bf316e27" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_suspend_interrupt_enabled</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SUSPE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga10bc6d84d73e1ecccae3318d4098c41a"></a><!-- doxytag: member="usbc_device.h::Is_udd_vbus_high" ref="ga10bc6d84d73e1ecccae3318d4098c41a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_vbus_high</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUS_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaed8ac44b2b2082c1797e873e120867c8"></a><!-- doxytag: member="usbc_device.h::Is_udd_vbus_interrupt_enabled" ref="gaed8ac44b2b2082c1797e873e120867c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_vbus_interrupt_enabled</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6f962d911e1863d143614d1ee01df89a"></a><!-- doxytag: member="usbc_device.h::Is_udd_vbus_low" ref="ga6f962d911e1863d143614d1ee01df89a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_vbus_low</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(!Is_udd_vbus_high())</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gafb6dd005e6fef2574f054b8fe5e8d008"></a><!-- doxytag: member="usbc_device.h::Is_udd_vbus_transition" ref="gafb6dd005e6fef2574f054b8fe5e8d008" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_vbus_transition</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUSTI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga27099aac5c46e62ca82775e957ae52a4"></a><!-- doxytag: member="usbc_device.h::Is_udd_wake_up" ref="ga27099aac5c46e62ca82775e957ae52a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_wake_up</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_WAKEUP_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaeab0126ceda728b5e100675a1368219a"></a><!-- doxytag: member="usbc_device.h::Is_udd_wake_up_interrupt_enabled" ref="gaeab0126ceda728b5e100675a1368219a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_wake_up_interrupt_enabled</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_WAKEUPE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga39c4b005d3194988c8969ea622eed23d"></a><!-- doxytag: member="usbc_device.h::udd_ack_remote_wake_up_start" ref="ga39c4b005d3194988c8969ea622eed23d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_remote_wake_up_start</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_UPRSMC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae28a4338a4679d081090a536f7bd3ee1"></a><!-- doxytag: member="usbc_device.h::udd_ack_reset" ref="gae28a4338a4679d081090a536f7bd3ee1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_reset</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSTC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabc25572243c4ab4600a1a870b4b6028b"></a><!-- doxytag: member="usbc_device.h::udd_ack_resume" ref="gabc25572243c4ab4600a1a870b4b6028b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_resume</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSMC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0b4140471f2e53d93cfe7f05ebd907d7"></a><!-- doxytag: member="usbc_device.h::udd_ack_sof" ref="ga0b4140471f2e53d93cfe7f05ebd907d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_sof</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SOFC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9a61b0228571cf2c0225c86f3e3a618e"></a><!-- doxytag: member="usbc_device.h::udd_ack_suspend" ref="ga9a61b0228571cf2c0225c86f3e3a618e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_suspend</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SUSPC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac6886b5956566ddb81744bbcfb27c08d"></a><!-- doxytag: member="usbc_device.h::udd_ack_vbus_transition" ref="gac6886b5956566ddb81744bbcfb27c08d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_vbus_transition</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.usbstaclr = AVR32_USBC_USBSTACLR_VBUSTIC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadf64e48ecbcfc8082ac438156d43311d"></a><!-- doxytag: member="usbc_device.h::udd_ack_wake_up" ref="gadf64e48ecbcfc8082ac438156d43311d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_wake_up</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_WAKEUPC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga55686d13fc7b23f4945f527f0dd15906"></a><!-- doxytag: member="usbc_device.h::udd_attach_device" ref="ga55686d13fc7b23f4945f527f0dd15906" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_attach_device</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>attaches to USB bus </p>

</div>
</div>
<a class="anchor" id="ga1863dacf593fb3c1b5f275b48f1e529a"></a><!-- doxytag: member="usbc_device.h::udd_detach_device" ref="ga1863dacf593fb3c1b5f275b48f1e529a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_detach_device</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>detaches from USB bus </p>

</div>
</div>
<a class="anchor" id="gad53f9dce1280a2b17218090cde573368"></a><!-- doxytag: member="usbc_device.h::udd_disable_remote_wake_up_interrupt" ref="gad53f9dce1280a2b17218090cde573368" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_remote_wake_up_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_UPRSMEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4f19c394e2352deb16c13e15c34c59ff"></a><!-- doxytag: member="usbc_device.h::udd_disable_reset_interrupt" ref="ga4f19c394e2352deb16c13e15c34c59ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_reset_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSTEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8a97ab6519a34ae7d9135fe70c6719e4"></a><!-- doxytag: member="usbc_device.h::udd_disable_resume_interrupt" ref="ga8a97ab6519a34ae7d9135fe70c6719e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_resume_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSMEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1210d31d31bcbcaf8374ac4db1521306"></a><!-- doxytag: member="usbc_device.h::udd_disable_sof_interrupt" ref="ga1210d31d31bcbcaf8374ac4db1521306" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_sof_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SOFEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1470fba0dbc68e890140d806277ee8c1"></a><!-- doxytag: member="usbc_device.h::udd_disable_suspend_interrupt" ref="ga1470fba0dbc68e890140d806277ee8c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_suspend_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SUSPEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad11887e29c08ad9cc6d67e3e6b4f9e9a"></a><!-- doxytag: member="usbc_device.h::udd_disable_vbus_interrupt" ref="gad11887e29c08ad9cc6d67e3e6b4f9e9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_vbus_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Clr_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaeac784d6d727d949449042d979d9a2ff"></a><!-- doxytag: member="usbc_device.h::udd_disable_wake_up_interrupt" ref="gaeac784d6d727d949449042d979d9a2ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_wake_up_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_WAKEUPEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0f538482266ca447cbfcfb9a5eb2bd64"></a><!-- doxytag: member="usbc_device.h::udd_enable_remote_wake_up_interrupt" ref="ga0f538482266ca447cbfcfb9a5eb2bd64" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_remote_wake_up_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_UPRSMES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manage upstream resume event (=remote wakeup) The USB driver sends a resume signal called "Upstream Resume" </p>

</div>
</div>
<a class="anchor" id="gaa4f338d7c02eb47691d55ea26a0b32d7"></a><!-- doxytag: member="usbc_device.h::udd_enable_reset_interrupt" ref="gaa4f338d7c02eb47691d55ea26a0b32d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_reset_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSTES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manage reset event Set when a USB "End of Reset" has been detected </p>

</div>
</div>
<a class="anchor" id="gad7f806ed3fbecb776acc5dcedcf81f3e"></a><!-- doxytag: member="usbc_device.h::udd_enable_resume_interrupt" ref="gad7f806ed3fbecb776acc5dcedcf81f3e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_resume_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSMES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manage end of resume event (=remote wakeup) The USB controller detects a valid "End of Resume" signal initiated by the host </p>

</div>
</div>
<a class="anchor" id="ga307066f7fb27b90020e50f7311b37ff6"></a><!-- doxytag: member="usbc_device.h::udd_enable_sof_interrupt" ref="ga307066f7fb27b90020e50f7311b37ff6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_sof_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SOFES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manage sart of frame event </p>

</div>
</div>
<a class="anchor" id="ga298cc43d16d7d9609d58adffe696b5db"></a><!-- doxytag: member="usbc_device.h::udd_enable_suspend_interrupt" ref="ga298cc43d16d7d9609d58adffe696b5db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_suspend_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SUSPES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manage suspend event </p>

</div>
</div>
<a class="anchor" id="gaf80c5f873a9d926ab3324b6a91dfd872"></a><!-- doxytag: member="usbc_device.h::udd_enable_vbus_interrupt" ref="gaf80c5f873a9d926ab3324b6a91dfd872" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_vbus_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Set_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1b192f6b945ae10b536deca002c2a1aa"></a><!-- doxytag: member="usbc_device.h::udd_enable_wake_up_interrupt" ref="ga1b192f6b945ae10b536deca002c2a1aa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_wake_up_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_WAKEUPES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Manage wake-up event (=usb line activity) The USB controller is reactivated by a filtered non-idle signal from the lines </p>

</div>
</div>
<a class="anchor" id="gac175ccc890008605691939957098a246"></a><!-- doxytag: member="usbc_device.h::udd_frame_number" ref="gac175ccc890008605691939957098a246" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_frame_number</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Rd_bitfield(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNUM_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4f3fc518ef0e369cc01a7bf7c6516844"></a><!-- doxytag: member="usbc_device.h::UDD_get_endpoint_max_nbr" ref="ga4f3fc518ef0e369cc01a7bf7c6516844" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_get_endpoint_max_nbr</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(((Rd_bitfield(AVR32_USBC_ufeatures, AVR32_USBC_UFEATURES_EPT_NBR_MAX_MASK) - 1) &amp; ((1 &lt;&lt; AVR32_USBC_UFEATURES_EPT_NBR_MAX_SIZE) - 1)) + 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get maximal number of endpoints. </p>

</div>
</div>
<a class="anchor" id="ga7adf42a2ec72e7f2429a9b02799333af"></a><!-- doxytag: member="usbc_device.h::udd_high_speed_disable" ref="ga7adf42a2ec72e7f2429a9b02799333af" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_high_speed_disable</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;do { } while (0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae014bb3adcdf212fd61196307be88802"></a><!-- doxytag: member="usbc_device.h::udd_high_speed_enable" ref="gae014bb3adcdf212fd61196307be88802" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_high_speed_enable</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;do { } while (0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacc4b62140d09930dd38b10f766d30517"></a><!-- doxytag: member="usbc_device.h::udd_initiate_remote_wake_up" ref="gacc4b62140d09930dd38b10f766d30517" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_initiate_remote_wake_up</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiates a remote wake-up event </p>

</div>
</div>
<a class="anchor" id="ga6471bbaea371bb9bb2654333236c9f29"></a><!-- doxytag: member="usbc_device.h::udd_low_speed_disable" ref="ga6471bbaea371bb9bb2654333236c9f29" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_low_speed_disable</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf272a0d4210ee260d0a267bba460fb0c"></a><!-- doxytag: member="usbc_device.h::udd_low_speed_enable" ref="gaf272a0d4210ee260d0a267bba460fb0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_low_speed_enable</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable/disable device low-speed mode. </p>

</div>
</div>
<a class="anchor" id="ga8e9d45e299d7a26b65bf8a98c8e27546"></a><!-- doxytag: member="usbc_device.h::udd_raise_remote_wake_up_start" ref="ga8e9d45e299d7a26b65bf8a98c8e27546" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_remote_wake_up_start</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_UPRSMS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6c25f895374748a59eaa9a84356a5d58"></a><!-- doxytag: member="usbc_device.h::udd_raise_reset" ref="ga6c25f895374748a59eaa9a84356a5d58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_reset</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSTS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga32a47c6752a2cac56874691e34728ba5"></a><!-- doxytag: member="usbc_device.h::udd_raise_resume" ref="ga32a47c6752a2cac56874691e34728ba5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_resume</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSMS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3747765066014e9bbde1bb263334c8a0"></a><!-- doxytag: member="usbc_device.h::udd_raise_sof" ref="ga3747765066014e9bbde1bb263334c8a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_sof</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SOFS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga997d9f1f31efd62ddcce775a4f40a0bd"></a><!-- doxytag: member="usbc_device.h::udd_raise_suspend" ref="ga997d9f1f31efd62ddcce775a4f40a0bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_suspend</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SUSPS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8761342ea2dc32e0f0252508b1f7c47a"></a><!-- doxytag: member="usbc_device.h::udd_raise_vbus_transition" ref="ga8761342ea2dc32e0f0252508b1f7c47a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_vbus_transition</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.usbstaset = AVR32_USBC_USBSTASET_VBUSTIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6b5a8ee09140c447b077c66c2e7668fe"></a><!-- doxytag: member="usbc_device.h::udd_raise_wake_up" ref="ga6b5a8ee09140c447b077c66c2e7668fe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_wake_up</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_WAKEUPS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaffd9b7cf165cd149868373fa12595d12"></a><!-- doxytag: member="udd.h::Udd_setup_is_in" ref="gaffd9b7cf165cd149868373fa12595d12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Udd_setup_is_in</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(USB_REQ_DIR_IN == (udd_g_ctrlreq.req.bmRequestType &amp; USB_REQ_DIR_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the setup request <em>udd_g_ctrlreq</em> indicates IN data transfer. </p>

</div>
</div>
<a class="anchor" id="gaf67b7c8de30fdc881b567385f2345926"></a><!-- doxytag: member="udd.h::Udd_setup_is_out" ref="gaf67b7c8de30fdc881b567385f2345926" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Udd_setup_is_out</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(USB_REQ_DIR_OUT == (udd_g_ctrlreq.req.bmRequestType &amp; USB_REQ_DIR_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the setup request <em>udd_g_ctrlreq</em> indicates OUT data transfer. </p>

</div>
</div>
<a class="anchor" id="gac963bb7b8a965c2fec45a71c9faca6f5"></a><!-- doxytag: member="udd.h::Udd_setup_recipient" ref="gac963bb7b8a965c2fec45a71c9faca6f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Udd_setup_recipient</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(udd_g_ctrlreq.req.bmRequestType &amp; USB_REQ_RECIP_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the recipient of the SETUP request <em>udd_g_ctrlreq</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>usb_recipient </dd></dl>

</div>
</div>
<a class="anchor" id="ga85dc2b7b6c270e8dd8323fa4779a7ca2"></a><!-- doxytag: member="udd.h::Udd_setup_type" ref="ga85dc2b7b6c270e8dd8323fa4779a7ca2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Udd_setup_type</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(udd_g_ctrlreq.req.bmRequestType &amp; USB_REQ_TYPE_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the type of the SETUP request <em>udd_g_ctrlreq</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>usb_reqtype. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90aeabbf00db4be8f0a1feef5cf0bbb3"></a><!-- doxytag: member="usbc_device.c::USBC_SLEEP_MODE_USB_IDLE" ref="ga90aeabbf00db4be8f0a1feef5cf0bbb3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBC_SLEEP_MODE_USB_IDLE&#160;&#160;&#160;SLEEPMGR_IDLE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf5ca2932775dabb853197df18706c469"></a><!-- doxytag: member="usbc_device.c::USBC_SLEEP_MODE_USB_SUSPEND" ref="gaf5ca2932775dabb853197df18706c469" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBC_SLEEP_MODE_USB_SUSPEND&#160;&#160;&#160;SLEEPMGR_STATIC</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition of sleep levels. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga7ab8d43f0761ecfb4d48770ac4ebb661"></a><!-- doxytag: member="udd.h::udd_callback_halt_cleared_t" ref="ga7ab8d43f0761ecfb4d48770ac4ebb661" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__udd__group.html#ga7ab8d43f0761ecfb4d48770ac4ebb661">udd_callback_halt_cleared_t</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>End of halt callback function type. Registered by routine udd_ep_wait_stall_clear() Callback called when endpoint stall is cleared. </p>

</div>
</div>
<a class="anchor" id="gad866ed9444482edcf92a28dce807e3d3"></a><!-- doxytag: member="udd.h::udd_callback_trans_t" ref="gad866ed9444482edcf92a28dce807e3d3" args=")(udd_ep_status_t status, iram_size_t nb_transfered)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__udd__group.html#gad866ed9444482edcf92a28dce807e3d3">udd_callback_trans_t</a>)(<a class="el" href="group__udd__group.html#gac0f77f5a0e085af1242b48fd1054959a">udd_ep_status_t</a> status, iram_size_t nb_transfered)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>End of transfer callback function type. Registered by routine udd_ep_run() Callback called by USB interrupt after data transfer or abort (reset,...). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>UDD_EP_TRANSFER_OK, if transfer is complete </td></tr>
    <tr><td class="paramname">status</td><td>UDD_EP_TRANSFER_ABORT, if transfer is aborted </td></tr>
    <tr><td class="paramname">n</td><td>number of data transfered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f25ea016c07bd48c3074f51d8ef8b01"></a><!-- doxytag: member="udd.h::udd_ep_id_t" ref="ga6f25ea016c07bd48c3074f51d8ef8b01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="group__udd__group.html#ga6f25ea016c07bd48c3074f51d8ef8b01">udd_ep_id_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Endpoint identifier. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gabc925782d47feeb37f6f943579038b84"></a><!-- doxytag: member="usbc_device.c::udd_ctrl_ep_state_t" ref="gabc925782d47feeb37f6f943579038b84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__udd__group.html#gabc925782d47feeb37f6f943579038b84">udd_ctrl_ep_state_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit definitions about endpoint control state machine for udd_ep_control_state. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84a2357a1ac77f59da70848f4121a016e77"></a><!-- doxytag: member="UDD_EPCTRL_SETUP" ref="ggabc925782d47feeb37f6f943579038b84a2357a1ac77f59da70848f4121a016e77" args="" -->UDD_EPCTRL_SETUP</em>&nbsp;</td><td>
<p>Wait a SETUP packet. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84acf3cc280a0061ecf321e0191d37dc53c"></a><!-- doxytag: member="UDD_EPCTRL_DATA_OUT" ref="ggabc925782d47feeb37f6f943579038b84acf3cc280a0061ecf321e0191d37dc53c" args="" -->UDD_EPCTRL_DATA_OUT</em>&nbsp;</td><td>
<p>Wait a OUT data packet. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84a57e63cb5de1f85c276dbfa8c3c00deed"></a><!-- doxytag: member="UDD_EPCTRL_DATA_IN" ref="ggabc925782d47feeb37f6f943579038b84a57e63cb5de1f85c276dbfa8c3c00deed" args="" -->UDD_EPCTRL_DATA_IN</em>&nbsp;</td><td>
<p>Wait a IN data packet. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84aadbf4f42e07b8589262e727b3cf8b900"></a><!-- doxytag: member="UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP" ref="ggabc925782d47feeb37f6f943579038b84aadbf4f42e07b8589262e727b3cf8b900" args="" -->UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP</em>&nbsp;</td><td>
<p>Wait a IN ZLP packet. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84ae5dd6cabf3ebb1aab6a80d7a92a89513"></a><!-- doxytag: member="UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP" ref="ggabc925782d47feeb37f6f943579038b84ae5dd6cabf3ebb1aab6a80d7a92a89513" args="" -->UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP</em>&nbsp;</td><td>
<p>Wait a OUT ZLP packet. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84a8d44562cd9ac18661adcf35015f8972e"></a><!-- doxytag: member="UDD_EPCTRL_STALL_REQ" ref="ggabc925782d47feeb37f6f943579038b84a8d44562cd9ac18661adcf35015f8972e" args="" -->UDD_EPCTRL_STALL_REQ</em>&nbsp;</td><td>
<p>STALL enabled on IN &amp; OUT packet. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gac0f77f5a0e085af1242b48fd1054959a"></a><!-- doxytag: member="udd.h::udd_ep_status_t" ref="gac0f77f5a0e085af1242b48fd1054959a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__udd__group.html#gac0f77f5a0e085af1242b48fd1054959a">udd_ep_status_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Endpoint transfer status Returned in parameters of callback register via udd_ep_run routine. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggac0f77f5a0e085af1242b48fd1054959aad52bb23180c67dc3d6a1d1dfedf74102"></a><!-- doxytag: member="UDD_EP_TRANSFER_OK" ref="ggac0f77f5a0e085af1242b48fd1054959aad52bb23180c67dc3d6a1d1dfedf74102" args="" -->UDD_EP_TRANSFER_OK</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac0f77f5a0e085af1242b48fd1054959aa010443246cb439e4f6f52b13c9d6e29c"></a><!-- doxytag: member="UDD_EP_TRANSFER_ABORT" ref="ggac0f77f5a0e085af1242b48fd1054959aa010443246cb439e4f6f52b13c9d6e29c" args="" -->UDD_EP_TRANSFER_ABORT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabe317a1520896eaf568afab27dc71540"></a><!-- doxytag: member="udd.h::COMPILER_PACK_RESET" ref="gabe317a1520896eaf568afab27dc71540" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">COMPILER_PACK_RESET </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga14096700b3ed8c5168615c5c5ee1c68d"></a><!-- doxytag: member="udd.h::COMPILER_PACK_SET" ref="ga14096700b3ed8c5168615c5c5ee1c68d" args="(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">COMPILER_PACK_SET </td>
          <td>(</td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A USB Device SETUP request. </p>
<p>SETUP packet contains following information. </p>

</div>
</div>
<a class="anchor" id="ga58c2916d7984e0e5b2143cadf4af6080"></a><!-- doxytag: member="udd.h::udc_process_setup" ref="ga58c2916d7984e0e5b2143cadf4af6080" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool udc_process_setup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decodes and manages a setup request. </p>
<p>The driver call it when a SETUP packet is received. The <code>udd_g_ctrlreq</code> contains the data of SETUP packet. If this callback accepts the setup request then it must return <code>1</code> and eventually update <code>udd_g_ctrlreq</code> to send or receive data.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>1</code> if the request is accepted, otherwise <code>0</code>.</dd></dl>
<p>Decodes and manages a setup request.</p>
<p>This function parses a USB SETUP request and submits an appropriate response back to the host or, in the case of SETUP OUT requests with data, sets up a buffer for receiving the data payload.</p>
<p>The main standard requests defined by the USB 2.0 standard are handled internally. The interface requests are sent to UDI, and the specific request sent to a specific application callback.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the request is supported, else the request is stalled by UDD </dd></dl>

</div>
</div>
<a class="anchor" id="ga11a32ff7928ba06d3b59e95e0a2b7a92"></a><!-- doxytag: member="udd.h::udc_reset" ref="ga11a32ff7928ba06d3b59e95e0a2b7a92" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the UDC. </p>
<p>The UDC must reset all configuration. </p>

</div>
</div>
<a class="anchor" id="ga4afae313045f44b5eb4c60957ab8ef4e"></a><!-- doxytag: member="udd.h::udc_sof_notify" ref="ga4afae313045f44b5eb4c60957ab8ef4e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_sof_notify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To signal that a SOF is occured. </p>
<p>The UDC must send the signal to all UDIs enabled </p>

</div>
</div>
<a class="anchor" id="ga7a7c0d9236c922c2af33c6702565a99f"></a><!-- doxytag: member="usbc_device.c::udd_attach" ref="ga7a7c0d9236c922c2af33c6702565a99f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_attach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach device to the bus when possible. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If a VBus control is included in driver, then it will attach device when an acceptable Vbus level from the host is detected. </dd></dl>

</div>
</div>
<a class="anchor" id="ga03e59eaa264f1dbe5a52559311d0520e"></a><!-- doxytag: member="usbc_device.c::udd_detach" ref="ga03e59eaa264f1dbe5a52559311d0520e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_detach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detaches the device from the bus. </p>
<p>The driver must remove pull-up on USB line D- or D+. </p>

</div>
</div>
<a class="anchor" id="gab283432057b934e9d73ac9282d9b0f11"></a><!-- doxytag: member="usbc_device.c::udd_disable" ref="gab283432057b934e9d73ac9282d9b0f11" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables the USB Device mode. </p>

</div>
</div>
<a class="anchor" id="ga9792d1899ae058e3984d6a622fe2ad42"></a><!-- doxytag: member="usbc_device.c::udd_enable" ref="ga9792d1899ae058e3984d6a622fe2ad42" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables the USB Device mode. </p>

</div>
</div>
<a class="anchor" id="ga96dc248cc05e07ffe2cf21e4d7465320"></a><!-- doxytag: member="usbc_device.c::udd_get_frame_number" ref="ga96dc248cc05e07ffe2cf21e4d7465320" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t udd_get_frame_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current start of frame number. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>current start of frame number. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63047eec59b8e8798ca1d3366472d82b"></a><!-- doxytag: member="usbc_device.c::udd_get_micro_frame_number" ref="ga63047eec59b8e8798ca1d3366472d82b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t udd_get_micro_frame_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current micro start of frame number. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>current micro start of frame number required in high speed mode. </dd></dl>

</div>
</div>
<a class="anchor" id="gaebd36638d482f6df00a8aff006ef2246"></a><!-- doxytag: member="usbc_device.c::udd_getaddress" ref="gaebd36638d482f6df00a8aff006ef2246" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t udd_getaddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the USB address of device. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>USB address </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4cac8c35ae056e26cf4ab5b426bbe09"></a><!-- doxytag: member="usbc_device.c::udd_include_vbus_monitoring" ref="gaa4cac8c35ae056e26cf4ab5b426bbe09" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool udd_include_vbus_monitoring </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Authorizes the VBUS event. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true, if the VBUS monitoring is possible. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85f403ddb78776b1ba014dafd3ffec2c"></a><!-- doxytag: member="usbc_device.c::udd_is_high_speed" ref="ga85f403ddb78776b1ba014dafd3ffec2c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool udd_is_high_speed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether the USB Device Controller is running at high speed or not. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the Device is running at high speed mode, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14ae6068206556d6ae8766b1baa2f686"></a><!-- doxytag: member="usbc_device.c::udd_send_wake_up" ref="ga14ae6068206556d6ae8766b1baa2f686" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_send_wake_up </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The USB driver sends a resume signal called Upstream Resume. </p>

</div>
</div>
<a class="anchor" id="ga05da762e0faf9d478e532de40afa71f6"></a><!-- doxytag: member="usbc_device.c::udd_set_address" ref="ga05da762e0faf9d478e532de40afa71f6" args="(uint8_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_set_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the USB address of device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>New USB address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga017ef5ea7626be258c24d345218976f9"></a><!-- doxytag: member="usbc_device.c::udd_set_setup_payload" ref="ga017ef5ea7626be258c24d345218976f9" args="(uint8_t *payload, uint16_t payload_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_set_setup_payload </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>payload_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load setup payload. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>Pointer on payload </td></tr>
    <tr><td class="paramname">payload_size</td><td>Size of payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga43ba1e91e69f84c1481a659ff8eff143"></a><!-- doxytag: member="udd.h::udd_test_mode_j" ref="ga43ba1e91e69f84c1481a659ff8eff143" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_test_mode_j </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2acd547bcd2b470ee4e1ce34087926a8"></a><!-- doxytag: member="udd.h::udd_test_mode_k" ref="ga2acd547bcd2b470ee4e1ce34087926a8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_test_mode_k </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab72f68f8d1a50f7e734595a2ff626380"></a><!-- doxytag: member="udd.h::udd_test_mode_packet" ref="gab72f68f8d1a50f7e734595a2ff626380" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_test_mode_packet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabec7e8b6464e92ca9c8f32c59113bcbb"></a><!-- doxytag: member="udd.h::udd_test_mode_se0_nak" ref="gabec7e8b6464e92ca9c8f32c59113bcbb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_test_mode_se0_nak </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga360872da67c7f8ecebe1238bbd4a536e"></a><!-- doxytag: member="udd.h::udd_g_ctrlreq" ref="ga360872da67c7f8ecebe1238bbd4a536e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structudd__ctrl__request__t.html">udd_ctrl_request_t</a> <a class="el" href="group__udd__group.html#ga360872da67c7f8ecebe1238bbd4a536e">udd_g_ctrlreq</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Global variable to give and record information about setup request management. </p>

</div>
</div>
<a class="anchor" id="ga2a41c2b14c5be825bdce7fde8c365a30"></a><!-- doxytag: member="usbc_device.c::udd_g_ctrlreq" ref="ga2a41c2b14c5be825bdce7fde8c365a30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">COMPILER_WORD_ALIGNED <a class="el" href="structudd__ctrl__request__t.html">udd_ctrl_request_t</a> <a class="el" href="group__udd__group.html#ga360872da67c7f8ecebe1238bbd4a536e">udd_g_ctrlreq</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Global variable to give and record information about setup request management. </p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2011 21:04:53 for OpenShoe by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
