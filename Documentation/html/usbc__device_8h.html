<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenShoe: usbc_device.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenShoe
   &#160;<span id="projectnumber">0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">usbc_device.h File Reference</div>  </div>
</div>
<div class="contents">

<p>USBC Device Driver header file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="compiler_8h_source.html">compiler.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="preprocessor_8h_source.html">preprocessor.h</a>&quot;</code><br/>
</div>
<p><a href="usbc__device_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr32__usbc__udesc__sizes__t.html">avr32_usbc_udesc_sizes_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr32__usbc__udesc__bk__ctrl__stat__t.html">avr32_usbc_udesc_bk_ctrl_stat_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr32__usbc__udesc__ep__ctrl__stat__t.html">avr32_usbc_udesc_ep_ctrl_stat_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structusb__desc__table__t.html">usb_desc_table_t</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device IP properties</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros give access to IP properties </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga4f3fc518ef0e369cc01a7bf7c6516844">UDD_get_endpoint_max_nbr</a>()&#160;&#160;&#160;(((Rd_bitfield(AVR32_USBC_ufeatures, AVR32_USBC_UFEATURES_EPT_NBR_MAX_MASK) - 1) &amp; ((1 &lt;&lt; AVR32_USBC_UFEATURES_EPT_NBR_MAX_SIZE) - 1)) + 1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal number of endpoints.  <a href="group__udd__group.html#ga4f3fc518ef0e369cc01a7bf7c6516844"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device speeds management</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf272a0d4210ee260d0a267bba460fb0c">udd_low_speed_enable</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable device low-speed mode.  <a href="group__udd__group.html#gaf272a0d4210ee260d0a267bba460fb0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6471bbaea371bb9bb2654333236c9f29">udd_low_speed_disable</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaedea021600d07a71a1672b393c550c39">Is_udd_low_speed_enable</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if device low-speed mode is forced.  <a href="group__udd__group.html#gaedea021600d07a71a1672b393c550c39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gae014bb3adcdf212fd61196307be88802">udd_high_speed_enable</a>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga7adf42a2ec72e7f2429a9b02799333af">udd_high_speed_disable</a>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga977c78f164f32fa910802518aab7b0ed">Is_udd_full_speed_mode</a>()&#160;&#160;&#160;true</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device vbus management</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf80c5f873a9d926ab3324b6a91dfd872">udd_enable_vbus_interrupt</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad11887e29c08ad9cc6d67e3e6b4f9e9a">udd_disable_vbus_interrupt</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaed8ac44b2b2082c1797e873e120867c8">Is_udd_vbus_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga10bc6d84d73e1ecccae3318d4098c41a">Is_udd_vbus_high</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUS_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6f962d911e1863d143614d1ee01df89a">Is_udd_vbus_low</a>()&#160;&#160;&#160;(!Is_udd_vbus_high())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gac6886b5956566ddb81744bbcfb27c08d">udd_ack_vbus_transition</a>()&#160;&#160;&#160;(AVR32_USBC.usbstaclr = AVR32_USBC_USBSTACLR_VBUSTIC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga8761342ea2dc32e0f0252508b1f7c47a">udd_raise_vbus_transition</a>()&#160;&#160;&#160;(AVR32_USBC.usbstaset = AVR32_USBC_USBSTASET_VBUSTIS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gafb6dd005e6fef2574f054b8fe5e8d008">Is_udd_vbus_transition</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUSTI_MASK))</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC device attach control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros manage the USBC Device attach. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1863dacf593fb3c1b5f275b48f1e529a">udd_detach_device</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">detaches from USB bus  <a href="group__udd__group.html#ga1863dacf593fb3c1b5f275b48f1e529a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga55686d13fc7b23f4945f527f0dd15906">udd_attach_device</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">attaches to USB bus  <a href="group__udd__group.html#ga55686d13fc7b23f4945f527f0dd15906"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf8c45e04066c136079dd296c2e28bb62">Is_udd_detached</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">test if the device is detached  <a href="group__udd__group.html#gaf8c45e04066c136079dd296c2e28bb62"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC device bus events control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros manage the USBC Device bus events. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gacc4b62140d09930dd38b10f766d30517">udd_initiate_remote_wake_up</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf3dab5078ad3286ac92d7b3a8cf8933a">Is_udd_pending_remote_wake_up</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga0f538482266ca447cbfcfb9a5eb2bd64">udd_enable_remote_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_UPRSMES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad53f9dce1280a2b17218090cde573368">udd_disable_remote_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_UPRSMEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga2a4c5935ae7ae26e8edf63a27d3d30d9">Is_udd_remote_wake_up_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_UPRSME_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga39c4b005d3194988c8969ea622eed23d">udd_ack_remote_wake_up_start</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_UPRSMC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga8e9d45e299d7a26b65bf8a98c8e27546">udd_raise_remote_wake_up_start</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_UPRSMS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gacfe73866ea62b418fe69fa061ef6edd3">Is_udd_remote_wake_up_start</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_UPRSM_MASK))</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad7f806ed3fbecb776acc5dcedcf81f3e">udd_enable_resume_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSMES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga8a97ab6519a34ae7d9135fe70c6719e4">udd_disable_resume_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSMEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga3cad513921d4190558aa7744d672bfc3">Is_udd_resume_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSME_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gabc25572243c4ab4600a1a870b4b6028b">udd_ack_resume</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSMC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga32a47c6752a2cac56874691e34728ba5">udd_raise_resume</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSMS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1b2ed8acdccb1fa2d295610349979fe5">Is_udd_resume</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORSM_MASK))</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1b192f6b945ae10b536deca002c2a1aa">udd_enable_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_WAKEUPES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaeac784d6d727d949449042d979d9a2ff">udd_disable_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_WAKEUPEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaeab0126ceda728b5e100675a1368219a">Is_udd_wake_up_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_WAKEUPE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gadf64e48ecbcfc8082ac438156d43311d">udd_ack_wake_up</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_WAKEUPC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6b5a8ee09140c447b077c66c2e7668fe">udd_raise_wake_up</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_WAKEUPS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga27099aac5c46e62ca82775e957ae52a4">Is_udd_wake_up</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_WAKEUP_MASK))</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaa4f338d7c02eb47691d55ea26a0b32d7">udd_enable_reset_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSTES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga4f19c394e2352deb16c13e15c34c59ff">udd_disable_reset_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSTEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gae0697533a9d3b806351a6a075100dd9f">Is_udd_reset_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSTE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gae28a4338a4679d081090a536f7bd3ee1">udd_ack_reset</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSTC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6c25f895374748a59eaa9a84356a5d58">udd_raise_reset</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSTS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga8bcb98dbb6f1255a0f25ae73035927db">Is_udd_reset</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORST_MASK))</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga307066f7fb27b90020e50f7311b37ff6">udd_enable_sof_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SOFES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1210d31d31bcbcaf8374ac4db1521306">udd_disable_sof_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SOFEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gacc090cdf3bd05a4da6888695fd95786b">Is_udd_sof_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SOFE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga0b4140471f2e53d93cfe7f05ebd907d7">udd_ack_sof</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SOFC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga3747765066014e9bbde1bb263334c8a0">udd_raise_sof</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SOFS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga5b5fcaa7cfa64de404ff9a3a257839a9">Is_udd_sof</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SOF_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gac175ccc890008605691939957098a246">udd_frame_number</a>()&#160;&#160;&#160;(Rd_bitfield(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNUM_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6f519fdc7583b259eb11d33555813182">Is_udd_frame_number_crc_error</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNCERR_MASK))</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga298cc43d16d7d9609d58adffe696b5db">udd_enable_suspend_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SUSPES_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1470fba0dbc68e890140d806277ee8c1">udd_disable_suspend_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SUSPEC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga2a9c882005f263ea9e181273bf316e27">Is_udd_suspend_interrupt_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SUSPE_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga9a61b0228571cf2c0225c86f3e3a618e">udd_ack_suspend</a>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SUSPC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga997d9f1f31efd62ddcce775a4f40a0bd">udd_raise_suspend</a>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SUSPS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gadfe9e8bbc2b3afefb19bcfd99db8b3fd">Is_udd_suspend</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SUSP_MASK))</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC device address control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros manage the USBC Device address. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a45ad65d26b8b1c07d438d6a953356adc">udd_enable_address</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_ADDEN_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables USB device address  <a href="#a45ad65d26b8b1c07d438d6a953356adc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a21a5e9eb44ea5fd15eb4e9c7603e77c6">udd_disable_address</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_ADDEN_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables USB device address  <a href="#a21a5e9eb44ea5fd15eb4e9c7603e77c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a745c69fca49259a55f097b89be266d9d">Is_udd_address_enabled</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_ADDEN_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5c6819ba3af1c84a7d7d33f059678e24">udd_configure_address</a>(addr)&#160;&#160;&#160;(Wr_bitfield(AVR32_USBC.udcon, AVR32_USBC_UDCON_UADD_MASK, addr))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the USB device address  <a href="#a5c6819ba3af1c84a7d7d33f059678e24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7abf42f819560e7da3b51d0ab6b73c33">udd_get_configured_address</a>()&#160;&#160;&#160;(Rd_bitfield(AVR32_USBC.udcon, AVR32_USBC_UDCON_UADD_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the currently configured USB device address  <a href="#a7abf42f819560e7da3b51d0ab6b73c33"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device endpoint drivers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros manage the common features of the endpoints. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(reg, index)&#160;&#160;&#160;((&amp;AVR32_USBC.reg)[(index)])</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Devcice endpoint configguration</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad03d0e3d03b41ad352bcfb1e20618cf3">udd_enable_endpoint</a>(ep)&#160;&#160;&#160;(Set_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPEN0_MASK &lt;&lt; (ep)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables the selected endpoint  <a href="#ad03d0e3d03b41ad352bcfb1e20618cf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a78448032b7215b5c3168c2219609f439">udd_disable_endpoint</a>(ep)&#160;&#160;&#160;(Clr_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPEN0_MASK &lt;&lt; (ep)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables the selected endpoint  <a href="#a78448032b7215b5c3168c2219609f439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#afe6904680ed0cc545a96efa2ca0d1a43">Is_udd_endpoint_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPEN0_MASK &lt;&lt; (ep)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the selected endpoint is enabled  <a href="#afe6904680ed0cc545a96efa2ca0d1a43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad104658f522a2947eac3ea93ec460ca9">udd_reset_endpoint</a>(ep)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the selected endpoint  <a href="#ad104658f522a2947eac3ea93ec460ca9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a73bc67a85520896969c812e3002b565e">Is_udd_resetting_endpoint</a>(ep)&#160;&#160;&#160;(Tst_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPRST0_MASK &lt;&lt; (ep)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the selected endpoint is being reset  <a href="#a73bc67a85520896969c812e3002b565e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a6cb296a52400f97a43b55679e95f0d1c">udd_configure_endpoint_type</a>(ep, type)&#160;&#160;&#160;(Wr_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPTYPE_MASK, type))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the selected endpoint type  <a href="#a6cb296a52400f97a43b55679e95f0d1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9038cc39fe44400c771b159f3ffe19e7">udd_get_endpoint_type</a>(ep)&#160;&#160;&#160;((Rd_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPTYPE_MASK))&gt;&gt;AVR32_USBC_UECFG0_EPTYPE_OFFSET)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the configured selected endpoint type  <a href="#a9038cc39fe44400c771b159f3ffe19e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#adf9bd49f7579a94166a10c4c6645f5de">udd_configure_endpoint_direction</a>(ep, dir)&#160;&#160;&#160;(Wr_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK, dir))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables the bank autoswitch for the selected endpoint  <a href="#adf9bd49f7579a94166a10c4c6645f5de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a1e9ebc6e500cfa654b2da58c235f1464">udd_get_endpoint_direction</a>(ep)&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the configured selected endpoint direction  <a href="#a1e9ebc6e500cfa654b2da58c235f1464"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ae9f80db7ea2439ef1fd11eaf0edceb91">Is_udd_endpoint_in</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9fc78147cab52be8b840973ef29d0076">udd_format_endpoint_size</a>(size)&#160;&#160;&#160;(32 - clz(((uint32_t)min(max(size, 8), 1024) &lt;&lt; 1) - 1) - 1 - 3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aed35d93ac28f5309919a8c6988baee47">udd_configure_endpoint_size</a>(ep, size)&#160;&#160;&#160;(Wr_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPSIZE_MASK, udd_format_endpoint_size(size)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the selected endpoint size  <a href="#aed35d93ac28f5309919a8c6988baee47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a16fa9454335f40118cc84efaa229c002">udd_get_endpoint_size</a>(ep)&#160;&#160;&#160;(8 &lt;&lt; Rd_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPSIZE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the configured selected endpoint size  <a href="#a16fa9454335f40118cc84efaa229c002"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5256fbd33ecb07fd5c1651f26d1b0313">udd_configure_endpoint_bank</a>(ep, bank)&#160;&#160;&#160;(Wr_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPBK_MASK, bank))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the selected endpoint number of banks  <a href="#a5256fbd33ecb07fd5c1651f26d1b0313"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#abfae08b406c33eff07a328c0a1bf9f48">udd_get_endpoint_bank</a>(ep)&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPBK_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the configured selected endpoint number of banks  <a href="#abfae08b406c33eff07a328c0a1bf9f48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ab0dd6d762bb7c07b3c085bfa77d7094a">udd_configure_endpoint</a>(ep, type, dir, size, bank)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">configures selected endpoint in one step  <a href="#ab0dd6d762bb7c07b3c085bfa77d7094a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ab535c15be47ca7b41b9af4fcc01cdc71">udd_control_direction</a>()&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uesta0(EP_CONTROL), AVR32_USBC_UESTA0_CTRLDIR_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the control direction  <a href="#ab535c15be47ca7b41b9af4fcc01cdc71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#af8215756ce1ffa8c2ae43bd44cd1b5ca">udd_reset_data_toggle</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_RSTDTS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the data toggle sequence  <a href="#af8215756ce1ffa8c2ae43bd44cd1b5ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aee6c06d0d3f8abf8cb14b4948782e6dd">Is_udd_data_toggle_reset</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_RSTDT_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the data toggle sequence is being reset  <a href="#aee6c06d0d3f8abf8cb14b4948782e6dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#abed983b720337e2ed5884d78e4519948">udd_data_toggle</a>(ep)&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_DTSEQ_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns data toggle  <a href="#abed983b720337e2ed5884d78e4519948"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device control endpoint interrupts</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros control the endpoints interrupts. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#afeee27d730e49f7182fb7e1b40649947">udd_enable_endpoint_interrupt</a>(ep)&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EP0INTES_MASK &lt;&lt; (ep))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables the selected endpoint interrupt  <a href="#afeee27d730e49f7182fb7e1b40649947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a8b172bafee7421956c3d195b8c30da92">udd_disable_endpoint_interrupt</a>(ep)&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EP0INTEC_MASK &lt;&lt; (ep))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables the selected endpoint interrupt  <a href="#a8b172bafee7421956c3d195b8c30da92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9b246cff0fb38d50d154b1e56dbd95fc">Is_udd_endpoint_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EP0INTE_MASK &lt;&lt; (ep)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the selected endpoint interrupt is enabled  <a href="#a9b246cff0fb38d50d154b1e56dbd95fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa12b636c365b3590aaab1685f5051e9d">Is_udd_endpoint_interrupt</a>(ep)&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EP0INT_MASK &lt;&lt; (ep)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if an interrupt is triggered by the selected endpoint  <a href="#aa12b636c365b3590aaab1685f5051e9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a2626b75423f2c54799bbeaf2c1fc816f">udd_get_interrupt_endpoint_number</a>()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the lowest endpoint number generating an endpoint interrupt or MAX_PEP_NB if none  <a href="#a2626b75423f2c54799bbeaf2c1fc816f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device control endpoint errors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros control the endpoint errors. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a53559e240871eefce5727db759814f67">udd_enable_stall_handshake</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_STALLRQS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables the STALL handshake  <a href="#a53559e240871eefce5727db759814f67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ab3ba0a5c25072f412af76337a9f78b49">udd_disable_stall_handshake</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_STALLRQC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables the STALL handshake  <a href="#ab3ba0a5c25072f412af76337a9f78b49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa00f503d09cc11156d7bcd275316fcc2">Is_udd_endpoint_stall_requested</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_STALLRQ_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if STALL handshake request is running  <a href="#aa00f503d09cc11156d7bcd275316fcc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa8f1423774570cc453649c43adffcde9">Is_udd_stall</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_STALLEDI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if STALL sent  <a href="#aa8f1423774570cc453649c43adffcde9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a80549eb8ff7c759ce3a0616ca2ff4e9a">udd_ack_stall</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_STALLEDIC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks STALL sent  <a href="#a80549eb8ff7c759ce3a0616ca2ff4e9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a18f2dcfdb7e62260eed0568dd4aae35e">udd_raise_stall</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_STALLEDIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises STALL sent  <a href="#a18f2dcfdb7e62260eed0568dd4aae35e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5d4273d7708a52f01c6c25ce1159d753">udd_enable_stall_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_STALLEDES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables STALL sent interrupt  <a href="#a5d4273d7708a52f01c6c25ce1159d753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7fec1c00b97a76215582b9245675a16f">udd_disable_stall_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_STALLEDEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables STALL sent interrupt  <a href="#a7fec1c00b97a76215582b9245675a16f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a328c29b9b3f54284bd7e2da8648e929c">Is_udd_stall_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_STALLEDE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if STALL sent interrupt is enabled  <a href="#a328c29b9b3f54284bd7e2da8648e929c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7a9485a3763e6f605fbe0d699eb769e0">Is_udd_ram_access_error</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_RAMACCERI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if a RAM access error occur  <a href="#a7a9485a3763e6f605fbe0d699eb769e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa662342744f36999b1e7f7b427e421e6">Is_udd_nak_out</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_NAKOUTI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if NAK OUT received  <a href="#aa662342744f36999b1e7f7b427e421e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9a6aad5b3ec3f719a107a804c1c6157f">udd_ack_nak_out</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_NAKOUTIC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks NAK OUT received  <a href="#a9a6aad5b3ec3f719a107a804c1c6157f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a04078a2d8249cf03c22ffad483e3e7dc">udd_raise_nak_out</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_NAKOUTIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises NAK OUT received  <a href="#a04078a2d8249cf03c22ffad483e3e7dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5b4d46dfc6148b45b9505c33ed3133e9">udd_enable_nak_out_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_NAKOUTES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables NAK OUT interrupt  <a href="#a5b4d46dfc6148b45b9505c33ed3133e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#afebfb5c623a09ce5a760ac43ba54a583">udd_disable_nak_out_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NAKOUTEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables NAK OUT interrupt  <a href="#afebfb5c623a09ce5a760ac43ba54a583"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa556fab3c46354bde3d2cdd02da700d1">Is_udd_nak_out_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_NAKOUTE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if NAK OUT interrupt is enabled  <a href="#aa556fab3c46354bde3d2cdd02da700d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a058bc49fc189ef865fe226cfcea4020b">Is_udd_nak_in</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_NAKINI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if NAK IN received  <a href="#a058bc49fc189ef865fe226cfcea4020b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9c7ff845a31408640d21ab1abe2a3ac3">udd_ack_nak_in</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_NAKINIC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks NAK IN received  <a href="#a9c7ff845a31408640d21ab1abe2a3ac3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#add81f92998f841a45c0bbe3d4f13c6fa">udd_raise_nak_in</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_NAKINIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises NAK IN received  <a href="#add81f92998f841a45c0bbe3d4f13c6fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#adbc5e8ee2fe92c01b938b09d6cbee804">udd_enable_nak_in_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_NAKINES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables NAK IN interrupt  <a href="#adbc5e8ee2fe92c01b938b09d6cbee804"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a1f2beebb3753a3b3e86aaaf93cb8b958">udd_disable_nak_in_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NAKINEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables NAK IN interrupt  <a href="#a1f2beebb3753a3b3e86aaaf93cb8b958"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a21d072c549f508c0bfa11877325ec6ca">Is_udd_nak_in_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_NAKINE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if NAK IN interrupt is enabled  <a href="#a21d072c549f508c0bfa11877325ec6ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a989c61a1ef03a3821e17a66a6ca47801">udd_ack_overflow_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_OVERFIC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks endpoint isochronous overflow interrupt  <a href="#a989c61a1ef03a3821e17a66a6ca47801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a1f5a81edfbab51799c3a60c2a24e14c8">udd_raise_overflow_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_OVERFIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises endpoint isochronous overflow interrupt  <a href="#a1f5a81edfbab51799c3a60c2a24e14c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a19a8109ed558b53a6c163ad4a1625ba1">Is_udd_overflow</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_OVERFI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if an overflow occurs  <a href="#a19a8109ed558b53a6c163ad4a1625ba1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7ef25a39e90ff903696c0c6b0cf4b573">udd_enable_overflow_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_OVERFES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables overflow interrupt  <a href="#a7ef25a39e90ff903696c0c6b0cf4b573"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aaae544aa935567496d6195ed4cd71ccc">udd_disable_overflow_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_OVERFEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables overflow interrupt  <a href="#aaae544aa935567496d6195ed4cd71ccc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a0eea027a8784874c6d9176c228d0bcfd">Is_udd_overflow_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_OVERFE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if overflow interrupt is enabled  <a href="#a0eea027a8784874c6d9176c228d0bcfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#adbe43b87bdd82e175d8dd4a70022f77d">udd_ack_underflow_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_UNDERFIC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks endpoint isochronous underflow interrupt  <a href="#adbe43b87bdd82e175d8dd4a70022f77d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ac62a73b450f839afd0fa9373a20b6572">udd_raise_underflow_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_UNDERFIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises endpoint isochronous underflow interrupt  <a href="#ac62a73b450f839afd0fa9373a20b6572"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a69cf9244b156e14a178ba1413f3efbc8">Is_udd_underflow</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_UNDERFI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if an underflow occurs  <a href="#a69cf9244b156e14a178ba1413f3efbc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5e6cd558da44828750e27cc78dba86e3">udd_enable_underflow_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_RXSTPES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables underflow interrupt  <a href="#a5e6cd558da44828750e27cc78dba86e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9414bf12df2ab83c146e18db3c185771">udd_disable_underflow_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_RXSTPEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables underflow interrupt  <a href="#a9414bf12df2ab83c146e18db3c185771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a162bf1796a65a0165303957fd2430970">Is_udd_underflow_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_RXSTPE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if underflow interrupt is enabled  <a href="#a162bf1796a65a0165303957fd2430970"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad6e25ea1e124ebe5ea9a6a9eb680b542">Is_udd_crc_error</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_STALLEDI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if CRC ERROR ISO OUT detected  <a href="#ad6e25ea1e124ebe5ea9a6a9eb680b542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a73241164f2b850d0a7e5a76f013c1922">udd_ack_crc_error</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_STALLEDIC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks CRC ERROR ISO OUT detected  <a href="#a73241164f2b850d0a7e5a76f013c1922"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a09c5d13c3b160178e0a1f18f50cc435b">udd_raise_crc_error</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_STALLEDIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises CRC ERROR ISO OUT detected  <a href="#a09c5d13c3b160178e0a1f18f50cc435b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a4bcf4430699577add8b0470749897371">udd_enable_crc_error_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_STALLEDES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables CRC ERROR ISO OUT detected interrupt  <a href="#a4bcf4430699577add8b0470749897371"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a63e2a523826ed3ac39ffec2bf5e430d7">udd_disable_crc_error_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_STALLEDEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables CRC ERROR ISO OUT detected interrupt  <a href="#a63e2a523826ed3ac39ffec2bf5e430d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a0a42c1b5a4d7f8231ea015f5ce9e652c">Is_udd_crc_error_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_STALLEDE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if CRC ERROR ISO OUT detected interrupt is enabled  <a href="#a0a42c1b5a4d7f8231ea015f5ce9e652c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device control endpoint banks</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros control the endpoint banks. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ac70a8020e42c03943b2e5cb247be6a27">udd_ack_fifocon</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_FIFOCONC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if endpoint read allowed  <a href="#ac70a8020e42c03943b2e5cb247be6a27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9b7eb71e23cbc004ff5e14d1b89ed5b5">Is_udd_fifocon</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_FIFOCON_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if FIFOCON bit set  <a href="#a9b7eb71e23cbc004ff5e14d1b89ed5b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aedfa79f446bab64bee7ba639045cae3f">udd_disable_nyet</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_NYETDISS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable NYET.  <a href="#aedfa79f446bab64bee7ba639045cae3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a19f3613c3c1aa1603c4c9f3e932be408">udd_enable_nyet</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NYETDISC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable NYET.  <a href="#a19f3613c3c1aa1603c4c9f3e932be408"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7808ee92bc219ec6bc161749fd8d8848">udd_enable_busy_bank0</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_BUSY0S_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable busy on bank0.  <a href="#a7808ee92bc219ec6bc161749fd8d8848"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ae00d2879deb19a5b70b0c1bf0cbabc2e">udd_disable_busy_bank0</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_BUSY0C_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable busy on bank0.  <a href="#ae00d2879deb19a5b70b0c1bf0cbabc2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9f195135bbeaa0aceb54dada54387a46">udd_enable_busy_bank1</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_BUSY1S_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable busy on bank1.  <a href="#a9f195135bbeaa0aceb54dada54387a46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a0e41b2c169fc026153b7be55266b5966">udd_disable_busy_bank1</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_BUSY1C_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable busy on bank1.  <a href="#a0e41b2c169fc026153b7be55266b5966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5c6d18d773abb7af0c1aa987006d7f86">udd_nb_busy_bank</a>(ep)&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_NBUSYBK_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of busy banks  <a href="#a5c6d18d773abb7af0c1aa987006d7f86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#add031c6e7450e25a69b04416514d7696">udd_current_bank</a>(ep)&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_CURRBK_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of the current bank  <a href="#add031c6e7450e25a69b04416514d7696"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a21f6ff4bffcd208971419ac13427bc61">udd_kill_last_in_bank</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_KILLBKS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">kills last bank  <a href="#a21f6ff4bffcd208971419ac13427bc61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a4de9e6f0520cb387d2db1bd71c91762b">Is_udd_last_in_bank_killed</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_KILLBK_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if last bank killed  <a href="#a4de9e6f0520cb387d2db1bd71c91762b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a64b05771e325d90e9ff6497a84c35e62">udd_force_bank_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_NBUSYBKS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">forces all banks full (OUT) or free (IN) interrupt  <a href="#a64b05771e325d90e9ff6497a84c35e62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa522e5e1d2f1d10c0e594b45cf7b8497">udd_unforce_bank_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_NBUSYBKS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">unforces all banks full (OUT) or free (IN) interrupt  <a href="#aa522e5e1d2f1d10c0e594b45cf7b8497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#affdee8df03c3087459da437f64409de1">udd_enable_bank_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_NBUSYBKES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables all banks full (OUT) or free (IN) interrupt  <a href="#affdee8df03c3087459da437f64409de1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#af9b9ee869302039a5a8e97186579eaaf">udd_disable_bank_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NBUSYBKEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables all banks full (OUT) or free (IN) interrupt  <a href="#af9b9ee869302039a5a8e97186579eaaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a6008ad2528d55b1830466e59e37ebc3a">Is_udd_bank_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_NBUSYBKE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if all banks full (OUT) or free (IN) interrupt enabled  <a href="#a6008ad2528d55b1830466e59e37ebc3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a329b1cde520fa81858ee360533d760c0">Is_udd_short_packet</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_SHORTPACKETI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if SHORT PACKET received  <a href="#a329b1cde520fa81858ee360533d760c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a583fd943c8a96f8561887cd996d6c05f">udd_ack_short_packet</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_SHORTPACKETIC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks SHORT PACKET received  <a href="#a583fd943c8a96f8561887cd996d6c05f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ac795af3e94f1202e6aab7b149632ab90">udd_raise_short_packet</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_SHORTPACKETIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises SHORT PACKET received  <a href="#ac795af3e94f1202e6aab7b149632ab90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a535f35b986fc195eb6a014cf9cfa8204">udd_enable_short_packet_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_SHORTPACKETES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables SHORT PACKET received interrupt  <a href="#a535f35b986fc195eb6a014cf9cfa8204"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5d5276a39a695e7fc7c72bd6dc68ba4d">udd_disable_short_packet_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_SHORTPACKETEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables SHORT PACKET received interrupt  <a href="#a5d5276a39a695e7fc7c72bd6dc68ba4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a4fb8e430cbdb750273e87a48b7e544c5">Is_udd_short_packet_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_SHORTPACKETE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if SHORT PACKET received interrupt is enabled  <a href="#a4fb8e430cbdb750273e87a48b7e544c5"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device control endpoint transfer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros control the endpoint transfers. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a35421aaff45c60a7174d7082db2941f4">Is_udd_setup_received</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_RXSTPI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if SETUP received  <a href="#a35421aaff45c60a7174d7082db2941f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#abf07f0798c3538c4306af26f1eb9ce2b">udd_ack_setup_received</a>(ep)&#160;&#160;&#160;((USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_RXSTPIC_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks SETUP received  <a href="#abf07f0798c3538c4306af26f1eb9ce2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a832e9941b31f7d7ba52cc0a2eb31e848">udd_raise_setup_received</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_RXSTPIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises SETUP received  <a href="#a832e9941b31f7d7ba52cc0a2eb31e848"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad50aa9e7b28504019f64a660d20d5160">udd_enable_setup_received_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_RXSTPES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables SETUP received interrupt  <a href="#ad50aa9e7b28504019f64a660d20d5160"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a668c58ec343f368da78ec9f15cae7373">udd_disable_setup_received_interrupt</a>()&#160;&#160;&#160;(USBC_ARRAY(uecon0clr(EP_CONTROL) = AVR32_USBC_UECON0CLR_RXSTPEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables SETUP received interrupt  <a href="#a668c58ec343f368da78ec9f15cae7373"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a4b4e77c5697efedbaa6ccef4f86dafcd">Is_udd_setup_received_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_RXSTPE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if SETUP received interrupt is enabled  <a href="#a4b4e77c5697efedbaa6ccef4f86dafcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a096c5fa1b85a21a8509f060f8dd6760c">Is_udd_out_received</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_RXOUTI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if OUT received  <a href="#a096c5fa1b85a21a8509f060f8dd6760c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a155aeea7bacc9d819976155da32ea20c">udd_ack_out_received</a>(ep)&#160;&#160;&#160;((USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_RXOUTIC_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks OUT received  <a href="#a155aeea7bacc9d819976155da32ea20c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a8aa1844030b75833ccab407a93f23c5b">udd_raise_out_received</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_RXOUTIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises OUT received  <a href="#a8aa1844030b75833ccab407a93f23c5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad2d31f9be235d1f0b61a92914caec150">udd_enable_out_received_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_RXOUTES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables OUT received interrupt  <a href="#ad2d31f9be235d1f0b61a92914caec150"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#acbef1c0e893909b48f08f369f5c2101e">udd_disable_out_received_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_RXOUTEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables OUT received interrupt  <a href="#acbef1c0e893909b48f08f369f5c2101e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#af91e68106149ba73e0e7a597d2f1f0e7">Is_udd_out_received_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_RXOUTE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if OUT received interrupt is enabled  <a href="#af91e68106149ba73e0e7a597d2f1f0e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aeda1e279c304f18c0e96827e41da9d86">Is_udd_in_send</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_TXINI_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if IN sending  <a href="#aeda1e279c304f18c0e96827e41da9d86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a11eb4dd0bf6c6694f1dccb3677d4b243">udd_ack_in_send</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_TXINIC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">acks IN sending  <a href="#a11eb4dd0bf6c6694f1dccb3677d4b243"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#afb1d0b8c2a38cbbece773c60206982a3">udd_raise_in_send</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_TXINIS_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">raises IN sending  <a href="#afb1d0b8c2a38cbbece773c60206982a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ae93fcd4e4efec3740ac5e4f97bda5603">udd_enable_in_send_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_TXINES_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enables IN sending interrupt  <a href="#ae93fcd4e4efec3740ac5e4f97bda5603"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a68bc029dbdcb3e938af79d00cad2ada6">udd_disable_in_send_interrupt</a>(ep)&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_TXINEC_MASK)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">disables IN sending interrupt  <a href="#a68bc029dbdcb3e938af79d00cad2ada6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ae4f86fc4a54e34216fd1defe06aca408">Is_udd_in_send_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_TXINE_MASK))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if IN sending interrupt is enabled  <a href="#ae4f86fc4a54e34216fd1defe06aca408"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">USB Device endpoints descriptor table management</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a18bc2b2f31d1aa60873c324c03a2dd2a">udd_udesc_set_buf0_addr</a>(ep, buf)&#160;&#160;&#160;udd_g_ep_table[ep*2].endpoint_pipe_address = buf</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a1b918dae2ab647e3ca3139e3fa1bd835">udd_udesc_rst_buf0_size</a>(ep)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.multi_packet_size = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a0c540ab90d24659e8fb8646b6341c1d4">udd_udesc_get_buf0_size</a>(ep)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.multi_packet_size</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a3c3cec924aa661853b77c7bfa217f5f8">udd_udesc_set_buf0_size</a>(ep, size)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.multi_packet_size = size</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a3d1c7b214972a5b48448d63174913a0c">udd_udesc_rst_buf0_ctn</a>(ep)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.byte_count = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a36dbb0f364c02ce1f3e8606063278824">udd_udesc_get_buf0_ctn</a>(ep)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.byte_count</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a33dbd2726ba58e81114c5a025548e479">udd_udesc_set_buf0_ctn</a>(ep, size)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.byte_count = size</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#adf40824e97da4c3c7cc651427bd2370c">udd_udesc_set_buf0_autozlp</a>(ep, val)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.auto_zlp = val</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#add60165f4e021c5e08c9b647e65496c8">Usb_set_desc_tab_addr_reg</a>(addr)&#160;&#160;&#160;(Wr_bitfield(AVR32_USBC.udesc, AVR32_USBC_UDESC_MASK, addr))</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>USBC Device Driver header file. </p>
<p>Copyright (C) 2009 Atmel Corporation. All rights reserved. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a745c69fca49259a55f097b89be266d9d"></a><!-- doxytag: member="usbc_device.h::Is_udd_address_enabled" ref="a745c69fca49259a55f097b89be266d9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_address_enabled</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_ADDEN_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6008ad2528d55b1830466e59e37ebc3a"></a><!-- doxytag: member="usbc_device.h::Is_udd_bank_interrupt_enabled" ref="a6008ad2528d55b1830466e59e37ebc3a" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_bank_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_NBUSYBKE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if all banks full (OUT) or free (IN) interrupt enabled </p>

</div>
</div>
<a class="anchor" id="ad6e25ea1e124ebe5ea9a6a9eb680b542"></a><!-- doxytag: member="usbc_device.h::Is_udd_crc_error" ref="ad6e25ea1e124ebe5ea9a6a9eb680b542" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_crc_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_STALLEDI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if CRC ERROR ISO OUT detected </p>

</div>
</div>
<a class="anchor" id="a0a42c1b5a4d7f8231ea015f5ce9e652c"></a><!-- doxytag: member="usbc_device.h::Is_udd_crc_error_interrupt_enabled" ref="a0a42c1b5a4d7f8231ea015f5ce9e652c" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_crc_error_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_STALLEDE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if CRC ERROR ISO OUT detected interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="aee6c06d0d3f8abf8cb14b4948782e6dd"></a><!-- doxytag: member="usbc_device.h::Is_udd_data_toggle_reset" ref="aee6c06d0d3f8abf8cb14b4948782e6dd" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_data_toggle_reset</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_RSTDT_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if the data toggle sequence is being reset </p>

</div>
</div>
<a class="anchor" id="afe6904680ed0cc545a96efa2ca0d1a43"></a><!-- doxytag: member="usbc_device.h::Is_udd_endpoint_enabled" ref="afe6904680ed0cc545a96efa2ca0d1a43" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_endpoint_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPEN0_MASK &lt;&lt; (ep)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if the selected endpoint is enabled </p>

</div>
</div>
<a class="anchor" id="ae9f80db7ea2439ef1fd11eaf0edceb91"></a><!-- doxytag: member="usbc_device.h::Is_udd_endpoint_in" ref="ae9f80db7ea2439ef1fd11eaf0edceb91" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_endpoint_in</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa12b636c365b3590aaab1685f5051e9d"></a><!-- doxytag: member="usbc_device.h::Is_udd_endpoint_interrupt" ref="aa12b636c365b3590aaab1685f5051e9d" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_endpoint_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EP0INT_MASK &lt;&lt; (ep)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if an interrupt is triggered by the selected endpoint </p>

</div>
</div>
<a class="anchor" id="a9b246cff0fb38d50d154b1e56dbd95fc"></a><!-- doxytag: member="usbc_device.h::Is_udd_endpoint_interrupt_enabled" ref="a9b246cff0fb38d50d154b1e56dbd95fc" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_endpoint_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EP0INTE_MASK &lt;&lt; (ep)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if the selected endpoint interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="aa00f503d09cc11156d7bcd275316fcc2"></a><!-- doxytag: member="usbc_device.h::Is_udd_endpoint_stall_requested" ref="aa00f503d09cc11156d7bcd275316fcc2" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_endpoint_stall_requested</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_STALLRQ_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if STALL handshake request is running </p>

</div>
</div>
<a class="anchor" id="a9b7eb71e23cbc004ff5e14d1b89ed5b5"></a><!-- doxytag: member="usbc_device.h::Is_udd_fifocon" ref="a9b7eb71e23cbc004ff5e14d1b89ed5b5" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_fifocon</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_FIFOCON_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if FIFOCON bit set </p>

</div>
</div>
<a class="anchor" id="aeda1e279c304f18c0e96827e41da9d86"></a><!-- doxytag: member="usbc_device.h::Is_udd_in_send" ref="aeda1e279c304f18c0e96827e41da9d86" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_in_send</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_TXINI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if IN sending </p>

</div>
</div>
<a class="anchor" id="ae4f86fc4a54e34216fd1defe06aca408"></a><!-- doxytag: member="usbc_device.h::Is_udd_in_send_interrupt_enabled" ref="ae4f86fc4a54e34216fd1defe06aca408" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_in_send_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_TXINE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if IN sending interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="a4de9e6f0520cb387d2db1bd71c91762b"></a><!-- doxytag: member="usbc_device.h::Is_udd_last_in_bank_killed" ref="a4de9e6f0520cb387d2db1bd71c91762b" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_last_in_bank_killed</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_KILLBK_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if last bank killed </p>

</div>
</div>
<a class="anchor" id="a058bc49fc189ef865fe226cfcea4020b"></a><!-- doxytag: member="usbc_device.h::Is_udd_nak_in" ref="a058bc49fc189ef865fe226cfcea4020b" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_nak_in</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_NAKINI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if NAK IN received </p>

</div>
</div>
<a class="anchor" id="a21d072c549f508c0bfa11877325ec6ca"></a><!-- doxytag: member="usbc_device.h::Is_udd_nak_in_interrupt_enabled" ref="a21d072c549f508c0bfa11877325ec6ca" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_nak_in_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_NAKINE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if NAK IN interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="aa662342744f36999b1e7f7b427e421e6"></a><!-- doxytag: member="usbc_device.h::Is_udd_nak_out" ref="aa662342744f36999b1e7f7b427e421e6" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_nak_out</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_NAKOUTI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if NAK OUT received </p>

</div>
</div>
<a class="anchor" id="aa556fab3c46354bde3d2cdd02da700d1"></a><!-- doxytag: member="usbc_device.h::Is_udd_nak_out_interrupt_enabled" ref="aa556fab3c46354bde3d2cdd02da700d1" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_nak_out_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_NAKOUTE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if NAK OUT interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="a096c5fa1b85a21a8509f060f8dd6760c"></a><!-- doxytag: member="usbc_device.h::Is_udd_out_received" ref="a096c5fa1b85a21a8509f060f8dd6760c" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_out_received</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_RXOUTI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if OUT received </p>

</div>
</div>
<a class="anchor" id="af91e68106149ba73e0e7a597d2f1f0e7"></a><!-- doxytag: member="usbc_device.h::Is_udd_out_received_interrupt_enabled" ref="af91e68106149ba73e0e7a597d2f1f0e7" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_out_received_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_RXOUTE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if OUT received interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="a19a8109ed558b53a6c163ad4a1625ba1"></a><!-- doxytag: member="usbc_device.h::Is_udd_overflow" ref="a19a8109ed558b53a6c163ad4a1625ba1" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_overflow</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_OVERFI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if an overflow occurs </p>

</div>
</div>
<a class="anchor" id="a0eea027a8784874c6d9176c228d0bcfd"></a><!-- doxytag: member="usbc_device.h::Is_udd_overflow_interrupt_enabled" ref="a0eea027a8784874c6d9176c228d0bcfd" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_overflow_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_OVERFE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if overflow interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="a7a9485a3763e6f605fbe0d699eb769e0"></a><!-- doxytag: member="usbc_device.h::Is_udd_ram_access_error" ref="a7a9485a3763e6f605fbe0d699eb769e0" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_ram_access_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_RAMACCERI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if a RAM access error occur </p>

</div>
</div>
<a class="anchor" id="a73bc67a85520896969c812e3002b565e"></a><!-- doxytag: member="usbc_device.h::Is_udd_resetting_endpoint" ref="a73bc67a85520896969c812e3002b565e" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_resetting_endpoint</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPRST0_MASK &lt;&lt; (ep)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if the selected endpoint is being reset </p>

</div>
</div>
<a class="anchor" id="a35421aaff45c60a7174d7082db2941f4"></a><!-- doxytag: member="usbc_device.h::Is_udd_setup_received" ref="a35421aaff45c60a7174d7082db2941f4" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_setup_received</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_RXSTPI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if SETUP received </p>

</div>
</div>
<a class="anchor" id="a4b4e77c5697efedbaa6ccef4f86dafcd"></a><!-- doxytag: member="usbc_device.h::Is_udd_setup_received_interrupt_enabled" ref="a4b4e77c5697efedbaa6ccef4f86dafcd" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_setup_received_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_RXSTPE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if SETUP received interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="a329b1cde520fa81858ee360533d760c0"></a><!-- doxytag: member="usbc_device.h::Is_udd_short_packet" ref="a329b1cde520fa81858ee360533d760c0" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_short_packet</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_SHORTPACKETI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if SHORT PACKET received </p>

</div>
</div>
<a class="anchor" id="a4fb8e430cbdb750273e87a48b7e544c5"></a><!-- doxytag: member="usbc_device.h::Is_udd_short_packet_interrupt_enabled" ref="a4fb8e430cbdb750273e87a48b7e544c5" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_short_packet_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_SHORTPACKETE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if SHORT PACKET received interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="aa8f1423774570cc453649c43adffcde9"></a><!-- doxytag: member="usbc_device.h::Is_udd_stall" ref="aa8f1423774570cc453649c43adffcde9" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_stall</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_STALLEDI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if STALL sent </p>

</div>
</div>
<a class="anchor" id="a328c29b9b3f54284bd7e2da8648e929c"></a><!-- doxytag: member="usbc_device.h::Is_udd_stall_interrupt_enabled" ref="a328c29b9b3f54284bd7e2da8648e929c" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_stall_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_STALLEDE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if STALL sent interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="a69cf9244b156e14a178ba1413f3efbc8"></a><!-- doxytag: member="usbc_device.h::Is_udd_underflow" ref="a69cf9244b156e14a178ba1413f3efbc8" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_underflow</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_UNDERFI_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if an underflow occurs </p>

</div>
</div>
<a class="anchor" id="a162bf1796a65a0165303957fd2430970"></a><!-- doxytag: member="usbc_device.h::Is_udd_underflow_interrupt_enabled" ref="a162bf1796a65a0165303957fd2430970" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Is_udd_underflow_interrupt_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Tst_bits(USBC_ARRAY(uecon0,ep), AVR32_USBC_UECON0_RXSTPE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if underflow interrupt is enabled </p>

</div>
</div>
<a class="anchor" id="a73241164f2b850d0a7e5a76f013c1922"></a><!-- doxytag: member="usbc_device.h::udd_ack_crc_error" ref="a73241164f2b850d0a7e5a76f013c1922" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_crc_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_STALLEDIC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks CRC ERROR ISO OUT detected </p>

</div>
</div>
<a class="anchor" id="ac70a8020e42c03943b2e5cb247be6a27"></a><!-- doxytag: member="usbc_device.h::udd_ack_fifocon" ref="ac70a8020e42c03943b2e5cb247be6a27" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_fifocon</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_FIFOCONC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests if endpoint read allowed </p>
<p>tests if endpoint write allowed clears FIFOCON bit </p>

</div>
</div>
<a class="anchor" id="a11eb4dd0bf6c6694f1dccb3677d4b243"></a><!-- doxytag: member="usbc_device.h::udd_ack_in_send" ref="a11eb4dd0bf6c6694f1dccb3677d4b243" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_in_send</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_TXINIC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks IN sending </p>

</div>
</div>
<a class="anchor" id="a9c7ff845a31408640d21ab1abe2a3ac3"></a><!-- doxytag: member="usbc_device.h::udd_ack_nak_in" ref="a9c7ff845a31408640d21ab1abe2a3ac3" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_nak_in</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_NAKINIC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks NAK IN received </p>

</div>
</div>
<a class="anchor" id="a9a6aad5b3ec3f719a107a804c1c6157f"></a><!-- doxytag: member="usbc_device.h::udd_ack_nak_out" ref="a9a6aad5b3ec3f719a107a804c1c6157f" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_nak_out</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_NAKOUTIC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks NAK OUT received </p>

</div>
</div>
<a class="anchor" id="a155aeea7bacc9d819976155da32ea20c"></a><!-- doxytag: member="usbc_device.h::udd_ack_out_received" ref="a155aeea7bacc9d819976155da32ea20c" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_out_received</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;((USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_RXOUTIC_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks OUT received </p>

</div>
</div>
<a class="anchor" id="a989c61a1ef03a3821e17a66a6ca47801"></a><!-- doxytag: member="usbc_device.h::udd_ack_overflow_interrupt" ref="a989c61a1ef03a3821e17a66a6ca47801" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_overflow_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_OVERFIC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks endpoint isochronous overflow interrupt </p>

</div>
</div>
<a class="anchor" id="abf07f0798c3538c4306af26f1eb9ce2b"></a><!-- doxytag: member="usbc_device.h::udd_ack_setup_received" ref="abf07f0798c3538c4306af26f1eb9ce2b" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_setup_received</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;((USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_RXSTPIC_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks SETUP received </p>

</div>
</div>
<a class="anchor" id="a583fd943c8a96f8561887cd996d6c05f"></a><!-- doxytag: member="usbc_device.h::udd_ack_short_packet" ref="a583fd943c8a96f8561887cd996d6c05f" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_short_packet</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_SHORTPACKETIC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks SHORT PACKET received </p>

</div>
</div>
<a class="anchor" id="a80549eb8ff7c759ce3a0616ca2ff4e9a"></a><!-- doxytag: member="usbc_device.h::udd_ack_stall" ref="a80549eb8ff7c759ce3a0616ca2ff4e9a" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_stall</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_STALLEDIC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks STALL sent </p>

</div>
</div>
<a class="anchor" id="adbe43b87bdd82e175d8dd4a70022f77d"></a><!-- doxytag: member="usbc_device.h::udd_ack_underflow_interrupt" ref="adbe43b87bdd82e175d8dd4a70022f77d" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_underflow_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_UNDERFIC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>acks endpoint isochronous underflow interrupt </p>

</div>
</div>
<a class="anchor" id="a5c6819ba3af1c84a7d7d33f059678e24"></a><!-- doxytag: member="usbc_device.h::udd_configure_address" ref="a5c6819ba3af1c84a7d7d33f059678e24" args="(addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_configure_address</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;(Wr_bitfield(AVR32_USBC.udcon, AVR32_USBC_UDCON_UADD_MASK, addr))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>configures the USB device address </p>

</div>
</div>
<a class="anchor" id="ab0dd6d762bb7c07b3c085bfa77d7094a"></a><!-- doxytag: member="usbc_device.h::udd_configure_endpoint" ref="ab0dd6d762bb7c07b3c085bfa77d7094a" args="(ep, type, dir, size, bank)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_configure_endpoint</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dir, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bank&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(\
   Wr_bits(<a class="code" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPTYPE_MASK |\
                                  AVR32_USBC_UECFG0_EPDIR_MASK  |\
                                  AVR32_USBC_UECFG0_EPSIZE_MASK |\
                                  AVR32_USBC_UECFG0_EPBK_MASK,   \
            (((uint32_t)(type) &lt;&lt; AVR32_USBC_UECFG0_EPTYPE_OFFSET) &amp; AVR32_USBC_UECFG0_EPTYPE_MASK) |\
            (((uint32_t)(dir ) &lt;&lt; AVR32_USBC_UECFG0_EPDIR_OFFSET ) &amp; AVR32_USBC_UECFG0_EPDIR_MASK ) |\
            ( (uint32_t)<a class="code" href="usbc__device_8h.html#a9fc78147cab52be8b840973ef29d0076">udd_format_endpoint_size</a>(size) &lt;&lt; AVR32_USBC_UECFG0_EPSIZE_OFFSET         ) |\
            (((uint32_t)(bank) &lt;&lt; AVR32_USBC_UECFG0_EPBK_OFFSET  ) &amp; AVR32_USBC_UECFG0_EPBK_MASK  ))\
)
</pre></div>
<p>configures selected endpoint in one step </p>

</div>
</div>
<a class="anchor" id="a5256fbd33ecb07fd5c1651f26d1b0313"></a><!-- doxytag: member="usbc_device.h::udd_configure_endpoint_bank" ref="a5256fbd33ecb07fd5c1651f26d1b0313" args="(ep, bank)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_configure_endpoint_bank</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bank&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(Wr_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPBK_MASK, bank))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>configures the selected endpoint number of banks </p>

</div>
</div>
<a class="anchor" id="adf9bd49f7579a94166a10c4c6645f5de"></a><!-- doxytag: member="usbc_device.h::udd_configure_endpoint_direction" ref="adf9bd49f7579a94166a10c4c6645f5de" args="(ep, dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_configure_endpoint_direction</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dir&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(Wr_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK, dir))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables the bank autoswitch for the selected endpoint </p>
<p>disables the bank autoswitch for the selected endpoint configures the selected endpoint direction </p>

</div>
</div>
<a class="anchor" id="aed35d93ac28f5309919a8c6988baee47"></a><!-- doxytag: member="usbc_device.h::udd_configure_endpoint_size" ref="aed35d93ac28f5309919a8c6988baee47" args="(ep, size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_configure_endpoint_size</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(Wr_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPSIZE_MASK, udd_format_endpoint_size(size)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>configures the selected endpoint size </p>

</div>
</div>
<a class="anchor" id="a6cb296a52400f97a43b55679e95f0d1c"></a><!-- doxytag: member="usbc_device.h::udd_configure_endpoint_type" ref="a6cb296a52400f97a43b55679e95f0d1c" args="(ep, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_configure_endpoint_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(Wr_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPTYPE_MASK, type))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>configures the selected endpoint type </p>

</div>
</div>
<a class="anchor" id="ab535c15be47ca7b41b9af4fcc01cdc71"></a><!-- doxytag: member="usbc_device.h::udd_control_direction" ref="ab535c15be47ca7b41b9af4fcc01cdc71" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_control_direction</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uesta0(EP_CONTROL), AVR32_USBC_UESTA0_CTRLDIR_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the control direction </p>

</div>
</div>
<a class="anchor" id="add031c6e7450e25a69b04416514d7696"></a><!-- doxytag: member="usbc_device.h::udd_current_bank" ref="add031c6e7450e25a69b04416514d7696" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_current_bank</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_CURRBK_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the number of the current bank </p>

</div>
</div>
<a class="anchor" id="abed983b720337e2ed5884d78e4519948"></a><!-- doxytag: member="usbc_device.h::udd_data_toggle" ref="abed983b720337e2ed5884d78e4519948" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_data_toggle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_DTSEQ_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns data toggle </p>

</div>
</div>
<a class="anchor" id="a21a5e9eb44ea5fd15eb4e9c7603e77c6"></a><!-- doxytag: member="usbc_device.h::udd_disable_address" ref="a21a5e9eb44ea5fd15eb4e9c7603e77c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_address</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_ADDEN_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables USB device address </p>

</div>
</div>
<a class="anchor" id="af9b9ee869302039a5a8e97186579eaaf"></a><!-- doxytag: member="usbc_device.h::udd_disable_bank_interrupt" ref="af9b9ee869302039a5a8e97186579eaaf" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_bank_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NBUSYBKEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables all banks full (OUT) or free (IN) interrupt </p>

</div>
</div>
<a class="anchor" id="ae00d2879deb19a5b70b0c1bf0cbabc2e"></a><!-- doxytag: member="usbc_device.h::udd_disable_busy_bank0" ref="ae00d2879deb19a5b70b0c1bf0cbabc2e" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_busy_bank0</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_BUSY0C_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable busy on bank0. </p>

</div>
</div>
<a class="anchor" id="a0e41b2c169fc026153b7be55266b5966"></a><!-- doxytag: member="usbc_device.h::udd_disable_busy_bank1" ref="a0e41b2c169fc026153b7be55266b5966" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_busy_bank1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_BUSY1C_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable busy on bank1. </p>

</div>
</div>
<a class="anchor" id="a63e2a523826ed3ac39ffec2bf5e430d7"></a><!-- doxytag: member="usbc_device.h::udd_disable_crc_error_interrupt" ref="a63e2a523826ed3ac39ffec2bf5e430d7" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_crc_error_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_STALLEDEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables CRC ERROR ISO OUT detected interrupt </p>

</div>
</div>
<a class="anchor" id="a78448032b7215b5c3168c2219609f439"></a><!-- doxytag: member="usbc_device.h::udd_disable_endpoint" ref="a78448032b7215b5c3168c2219609f439" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_endpoint</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Clr_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPEN0_MASK &lt;&lt; (ep)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables the selected endpoint </p>

</div>
</div>
<a class="anchor" id="a8b172bafee7421956c3d195b8c30da92"></a><!-- doxytag: member="usbc_device.h::udd_disable_endpoint_interrupt" ref="a8b172bafee7421956c3d195b8c30da92" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_endpoint_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EP0INTEC_MASK &lt;&lt; (ep))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables the selected endpoint interrupt </p>

</div>
</div>
<a class="anchor" id="a68bc029dbdcb3e938af79d00cad2ada6"></a><!-- doxytag: member="usbc_device.h::udd_disable_in_send_interrupt" ref="a68bc029dbdcb3e938af79d00cad2ada6" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_in_send_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_TXINEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables IN sending interrupt </p>

</div>
</div>
<a class="anchor" id="a1f2beebb3753a3b3e86aaaf93cb8b958"></a><!-- doxytag: member="usbc_device.h::udd_disable_nak_in_interrupt" ref="a1f2beebb3753a3b3e86aaaf93cb8b958" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_nak_in_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NAKINEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables NAK IN interrupt </p>

</div>
</div>
<a class="anchor" id="afebfb5c623a09ce5a760ac43ba54a583"></a><!-- doxytag: member="usbc_device.h::udd_disable_nak_out_interrupt" ref="afebfb5c623a09ce5a760ac43ba54a583" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_nak_out_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NAKOUTEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables NAK OUT interrupt </p>

</div>
</div>
<a class="anchor" id="aedfa79f446bab64bee7ba639045cae3f"></a><!-- doxytag: member="usbc_device.h::udd_disable_nyet" ref="aedfa79f446bab64bee7ba639045cae3f" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_nyet</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_NYETDISS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable NYET. </p>

</div>
</div>
<a class="anchor" id="acbef1c0e893909b48f08f369f5c2101e"></a><!-- doxytag: member="usbc_device.h::udd_disable_out_received_interrupt" ref="acbef1c0e893909b48f08f369f5c2101e" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_out_received_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_RXOUTEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables OUT received interrupt </p>

</div>
</div>
<a class="anchor" id="aaae544aa935567496d6195ed4cd71ccc"></a><!-- doxytag: member="usbc_device.h::udd_disable_overflow_interrupt" ref="aaae544aa935567496d6195ed4cd71ccc" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_overflow_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_OVERFEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables overflow interrupt </p>

</div>
</div>
<a class="anchor" id="a668c58ec343f368da78ec9f15cae7373"></a><!-- doxytag: member="usbc_device.h::udd_disable_setup_received_interrupt" ref="a668c58ec343f368da78ec9f15cae7373" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_setup_received_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr(EP_CONTROL) = AVR32_USBC_UECON0CLR_RXSTPEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables SETUP received interrupt </p>

</div>
</div>
<a class="anchor" id="a5d5276a39a695e7fc7c72bd6dc68ba4d"></a><!-- doxytag: member="usbc_device.h::udd_disable_short_packet_interrupt" ref="a5d5276a39a695e7fc7c72bd6dc68ba4d" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_short_packet_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_SHORTPACKETEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables SHORT PACKET received interrupt </p>

</div>
</div>
<a class="anchor" id="ab3ba0a5c25072f412af76337a9f78b49"></a><!-- doxytag: member="usbc_device.h::udd_disable_stall_handshake" ref="ab3ba0a5c25072f412af76337a9f78b49" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_stall_handshake</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_STALLRQC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables the STALL handshake </p>

</div>
</div>
<a class="anchor" id="a7fec1c00b97a76215582b9245675a16f"></a><!-- doxytag: member="usbc_device.h::udd_disable_stall_interrupt" ref="a7fec1c00b97a76215582b9245675a16f" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_stall_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_STALLEDEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables STALL sent interrupt </p>

</div>
</div>
<a class="anchor" id="a9414bf12df2ab83c146e18db3c185771"></a><!-- doxytag: member="usbc_device.h::udd_disable_underflow_interrupt" ref="a9414bf12df2ab83c146e18db3c185771" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_disable_underflow_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_RXSTPEC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>disables underflow interrupt </p>

</div>
</div>
<a class="anchor" id="a45ad65d26b8b1c07d438d6a953356adc"></a><!-- doxytag: member="usbc_device.h::udd_enable_address" ref="a45ad65d26b8b1c07d438d6a953356adc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_address</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_ADDEN_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables USB device address </p>

</div>
</div>
<a class="anchor" id="affdee8df03c3087459da437f64409de1"></a><!-- doxytag: member="usbc_device.h::udd_enable_bank_interrupt" ref="affdee8df03c3087459da437f64409de1" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_bank_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_NBUSYBKES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables all banks full (OUT) or free (IN) interrupt </p>

</div>
</div>
<a class="anchor" id="a7808ee92bc219ec6bc161749fd8d8848"></a><!-- doxytag: member="usbc_device.h::udd_enable_busy_bank0" ref="a7808ee92bc219ec6bc161749fd8d8848" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_busy_bank0</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_BUSY0S_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable busy on bank0. </p>

</div>
</div>
<a class="anchor" id="a9f195135bbeaa0aceb54dada54387a46"></a><!-- doxytag: member="usbc_device.h::udd_enable_busy_bank1" ref="a9f195135bbeaa0aceb54dada54387a46" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_busy_bank1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_BUSY1S_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable busy on bank1. </p>

</div>
</div>
<a class="anchor" id="a4bcf4430699577add8b0470749897371"></a><!-- doxytag: member="usbc_device.h::udd_enable_crc_error_interrupt" ref="a4bcf4430699577add8b0470749897371" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_crc_error_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_STALLEDES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables CRC ERROR ISO OUT detected interrupt </p>

</div>
</div>
<a class="anchor" id="ad03d0e3d03b41ad352bcfb1e20618cf3"></a><!-- doxytag: member="usbc_device.h::udd_enable_endpoint" ref="ad03d0e3d03b41ad352bcfb1e20618cf3" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_endpoint</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Set_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPEN0_MASK &lt;&lt; (ep)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables the selected endpoint </p>

</div>
</div>
<a class="anchor" id="afeee27d730e49f7182fb7e1b40649947"></a><!-- doxytag: member="usbc_device.h::udd_enable_endpoint_interrupt" ref="afeee27d730e49f7182fb7e1b40649947" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_endpoint_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EP0INTES_MASK &lt;&lt; (ep))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables the selected endpoint interrupt </p>

</div>
</div>
<a class="anchor" id="ae93fcd4e4efec3740ac5e4f97bda5603"></a><!-- doxytag: member="usbc_device.h::udd_enable_in_send_interrupt" ref="ae93fcd4e4efec3740ac5e4f97bda5603" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_in_send_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_TXINES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables IN sending interrupt </p>

</div>
</div>
<a class="anchor" id="adbc5e8ee2fe92c01b938b09d6cbee804"></a><!-- doxytag: member="usbc_device.h::udd_enable_nak_in_interrupt" ref="adbc5e8ee2fe92c01b938b09d6cbee804" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_nak_in_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_NAKINES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables NAK IN interrupt </p>

</div>
</div>
<a class="anchor" id="a5b4d46dfc6148b45b9505c33ed3133e9"></a><!-- doxytag: member="usbc_device.h::udd_enable_nak_out_interrupt" ref="a5b4d46dfc6148b45b9505c33ed3133e9" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_nak_out_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_NAKOUTES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables NAK OUT interrupt </p>

</div>
</div>
<a class="anchor" id="a19f3613c3c1aa1603c4c9f3e932be408"></a><!-- doxytag: member="usbc_device.h::udd_enable_nyet" ref="a19f3613c3c1aa1603c4c9f3e932be408" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_nyet</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NYETDISC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable NYET. </p>

</div>
</div>
<a class="anchor" id="ad2d31f9be235d1f0b61a92914caec150"></a><!-- doxytag: member="usbc_device.h::udd_enable_out_received_interrupt" ref="ad2d31f9be235d1f0b61a92914caec150" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_out_received_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_RXOUTES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables OUT received interrupt </p>

</div>
</div>
<a class="anchor" id="a7ef25a39e90ff903696c0c6b0cf4b573"></a><!-- doxytag: member="usbc_device.h::udd_enable_overflow_interrupt" ref="a7ef25a39e90ff903696c0c6b0cf4b573" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_overflow_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_OVERFES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables overflow interrupt </p>

</div>
</div>
<a class="anchor" id="ad50aa9e7b28504019f64a660d20d5160"></a><!-- doxytag: member="usbc_device.h::udd_enable_setup_received_interrupt" ref="ad50aa9e7b28504019f64a660d20d5160" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_setup_received_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_RXSTPES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables SETUP received interrupt </p>

</div>
</div>
<a class="anchor" id="a535f35b986fc195eb6a014cf9cfa8204"></a><!-- doxytag: member="usbc_device.h::udd_enable_short_packet_interrupt" ref="a535f35b986fc195eb6a014cf9cfa8204" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_short_packet_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_SHORTPACKETES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables SHORT PACKET received interrupt </p>

</div>
</div>
<a class="anchor" id="a53559e240871eefce5727db759814f67"></a><!-- doxytag: member="usbc_device.h::udd_enable_stall_handshake" ref="a53559e240871eefce5727db759814f67" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_stall_handshake</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_STALLRQS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables the STALL handshake </p>

</div>
</div>
<a class="anchor" id="a5d4273d7708a52f01c6c25ce1159d753"></a><!-- doxytag: member="usbc_device.h::udd_enable_stall_interrupt" ref="a5d4273d7708a52f01c6c25ce1159d753" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_stall_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_STALLEDES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables STALL sent interrupt </p>

</div>
</div>
<a class="anchor" id="a5e6cd558da44828750e27cc78dba86e3"></a><!-- doxytag: member="usbc_device.h::udd_enable_underflow_interrupt" ref="a5e6cd558da44828750e27cc78dba86e3" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_underflow_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_RXSTPES_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enables underflow interrupt </p>

</div>
</div>
<a class="anchor" id="a64b05771e325d90e9ff6497a84c35e62"></a><!-- doxytag: member="usbc_device.h::udd_force_bank_interrupt" ref="a64b05771e325d90e9ff6497a84c35e62" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_force_bank_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_NBUSYBKS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>forces all banks full (OUT) or free (IN) interrupt </p>

</div>
</div>
<a class="anchor" id="a9fc78147cab52be8b840973ef29d0076"></a><!-- doxytag: member="usbc_device.h::udd_format_endpoint_size" ref="a9fc78147cab52be8b840973ef29d0076" args="(size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_format_endpoint_size</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;(32 - clz(((uint32_t)min(max(size, 8), 1024) &lt;&lt; 1) - 1) - 1 - 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bounds given integer size to allowed range and rounds it up to the nearest available greater size, then applies register format of USBC controller for endpoint size bit-field. </p>

</div>
</div>
<a class="anchor" id="a7abf42f819560e7da3b51d0ab6b73c33"></a><!-- doxytag: member="usbc_device.h::udd_get_configured_address" ref="a7abf42f819560e7da3b51d0ab6b73c33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_get_configured_address</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Rd_bitfield(AVR32_USBC.udcon, AVR32_USBC_UDCON_UADD_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the currently configured USB device address </p>

</div>
</div>
<a class="anchor" id="abfae08b406c33eff07a328c0a1bf9f48"></a><!-- doxytag: member="usbc_device.h::udd_get_endpoint_bank" ref="abfae08b406c33eff07a328c0a1bf9f48" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_get_endpoint_bank</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPBK_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the configured selected endpoint number of banks </p>

</div>
</div>
<a class="anchor" id="a1e9ebc6e500cfa654b2da58c235f1464"></a><!-- doxytag: member="usbc_device.h::udd_get_endpoint_direction" ref="a1e9ebc6e500cfa654b2da58c235f1464" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_get_endpoint_direction</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the configured selected endpoint direction </p>

</div>
</div>
<a class="anchor" id="a16fa9454335f40118cc84efaa229c002"></a><!-- doxytag: member="usbc_device.h::udd_get_endpoint_size" ref="a16fa9454335f40118cc84efaa229c002" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_get_endpoint_size</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(8 &lt;&lt; Rd_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPSIZE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the configured selected endpoint size </p>

</div>
</div>
<a class="anchor" id="a9038cc39fe44400c771b159f3ffe19e7"></a><!-- doxytag: member="usbc_device.h::udd_get_endpoint_type" ref="a9038cc39fe44400c771b159f3ffe19e7" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_get_endpoint_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;((Rd_bitfield(USBC_ARRAY(uecfg0,ep), AVR32_USBC_UECFG0_EPTYPE_MASK))&gt;&gt;AVR32_USBC_UECFG0_EPTYPE_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the configured selected endpoint type </p>

</div>
</div>
<a class="anchor" id="a2626b75423f2c54799bbeaf2c1fc816f"></a><!-- doxytag: member="usbc_device.h::udd_get_interrupt_endpoint_number" ref="a2626b75423f2c54799bbeaf2c1fc816f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_get_interrupt_endpoint_number</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(ctz(((AVR32_USBC.udint &gt;&gt; AVR32_USBC_UDINT_EP0INT_OFFSET) &amp;\
                                                   (AVR32_USBC.udinte &gt;&gt; AVR32_USBC_UDINTE_EP0INTE_OFFSET)) |\
                                                   (1 &lt;&lt; MAX_PEP_NB)))
</pre></div>
<p>returns the lowest endpoint number generating an endpoint interrupt or MAX_PEP_NB if none </p>

</div>
</div>
<a class="anchor" id="a21f6ff4bffcd208971419ac13427bc61"></a><!-- doxytag: member="usbc_device.h::udd_kill_last_in_bank" ref="a21f6ff4bffcd208971419ac13427bc61" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_kill_last_in_bank</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_KILLBKS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>kills last bank </p>

</div>
</div>
<a class="anchor" id="a5c6d18d773abb7af0c1aa987006d7f86"></a><!-- doxytag: member="usbc_device.h::udd_nb_busy_bank" ref="a5c6d18d773abb7af0c1aa987006d7f86" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_nb_busy_bank</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(Rd_bitfield(USBC_ARRAY(uesta0,ep), AVR32_USBC_UESTA0_NBUSYBK_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the number of busy banks </p>

</div>
</div>
<a class="anchor" id="a09c5d13c3b160178e0a1f18f50cc435b"></a><!-- doxytag: member="usbc_device.h::udd_raise_crc_error" ref="a09c5d13c3b160178e0a1f18f50cc435b" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_crc_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_STALLEDIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises CRC ERROR ISO OUT detected </p>

</div>
</div>
<a class="anchor" id="afb1d0b8c2a38cbbece773c60206982a3"></a><!-- doxytag: member="usbc_device.h::udd_raise_in_send" ref="afb1d0b8c2a38cbbece773c60206982a3" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_in_send</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_TXINIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises IN sending </p>

</div>
</div>
<a class="anchor" id="add81f92998f841a45c0bbe3d4f13c6fa"></a><!-- doxytag: member="usbc_device.h::udd_raise_nak_in" ref="add81f92998f841a45c0bbe3d4f13c6fa" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_nak_in</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_NAKINIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises NAK IN received </p>

</div>
</div>
<a class="anchor" id="a04078a2d8249cf03c22ffad483e3e7dc"></a><!-- doxytag: member="usbc_device.h::udd_raise_nak_out" ref="a04078a2d8249cf03c22ffad483e3e7dc" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_nak_out</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_NAKOUTIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises NAK OUT received </p>

</div>
</div>
<a class="anchor" id="a8aa1844030b75833ccab407a93f23c5b"></a><!-- doxytag: member="usbc_device.h::udd_raise_out_received" ref="a8aa1844030b75833ccab407a93f23c5b" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_out_received</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_RXOUTIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises OUT received </p>

</div>
</div>
<a class="anchor" id="a1f5a81edfbab51799c3a60c2a24e14c8"></a><!-- doxytag: member="usbc_device.h::udd_raise_overflow_interrupt" ref="a1f5a81edfbab51799c3a60c2a24e14c8" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_overflow_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_OVERFIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises endpoint isochronous overflow interrupt </p>

</div>
</div>
<a class="anchor" id="a832e9941b31f7d7ba52cc0a2eb31e848"></a><!-- doxytag: member="usbc_device.h::udd_raise_setup_received" ref="a832e9941b31f7d7ba52cc0a2eb31e848" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_setup_received</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_RXSTPIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises SETUP received </p>

</div>
</div>
<a class="anchor" id="ac795af3e94f1202e6aab7b149632ab90"></a><!-- doxytag: member="usbc_device.h::udd_raise_short_packet" ref="ac795af3e94f1202e6aab7b149632ab90" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_short_packet</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_SHORTPACKETIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises SHORT PACKET received </p>

</div>
</div>
<a class="anchor" id="a18f2dcfdb7e62260eed0568dd4aae35e"></a><!-- doxytag: member="usbc_device.h::udd_raise_stall" ref="a18f2dcfdb7e62260eed0568dd4aae35e" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_stall</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_STALLEDIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises STALL sent </p>

</div>
</div>
<a class="anchor" id="ac62a73b450f839afd0fa9373a20b6572"></a><!-- doxytag: member="usbc_device.h::udd_raise_underflow_interrupt" ref="ac62a73b450f839afd0fa9373a20b6572" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_raise_underflow_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_UNDERFIS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>raises endpoint isochronous underflow interrupt </p>

</div>
</div>
<a class="anchor" id="af8215756ce1ffa8c2ae43bd44cd1b5ca"></a><!-- doxytag: member="usbc_device.h::udd_reset_data_toggle" ref="af8215756ce1ffa8c2ae43bd44cd1b5ca" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_reset_data_toggle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uecon0set,ep) = AVR32_USBC_UECON0SET_RSTDTS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>resets the data toggle sequence </p>

</div>
</div>
<a class="anchor" id="ad104658f522a2947eac3ea93ec460ca9"></a><!-- doxytag: member="usbc_device.h::udd_reset_endpoint" ref="ad104658f522a2947eac3ea93ec460ca9" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_reset_endpoint</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(Set_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPRST0_MASK &lt;&lt; (ep)),\
                                                   Clr_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPRST0_MASK &lt;&lt; (ep)))
</pre></div>
<p>resets the selected endpoint </p>

</div>
</div>
<a class="anchor" id="a36dbb0f364c02ce1f3e8606063278824"></a><!-- doxytag: member="usbc_device.h::udd_udesc_get_buf0_ctn" ref="a36dbb0f364c02ce1f3e8606063278824" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_udesc_get_buf0_ctn</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.byte_count</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c540ab90d24659e8fb8646b6341c1d4"></a><!-- doxytag: member="usbc_device.h::udd_udesc_get_buf0_size" ref="a0c540ab90d24659e8fb8646b6341c1d4" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_udesc_get_buf0_size</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.multi_packet_size</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3d1c7b214972a5b48448d63174913a0c"></a><!-- doxytag: member="usbc_device.h::udd_udesc_rst_buf0_ctn" ref="a3d1c7b214972a5b48448d63174913a0c" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_udesc_rst_buf0_ctn</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.byte_count = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b918dae2ab647e3ca3139e3fa1bd835"></a><!-- doxytag: member="usbc_device.h::udd_udesc_rst_buf0_size" ref="a1b918dae2ab647e3ca3139e3fa1bd835" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_udesc_rst_buf0_size</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.multi_packet_size = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18bc2b2f31d1aa60873c324c03a2dd2a"></a><!-- doxytag: member="usbc_device.h::udd_udesc_set_buf0_addr" ref="a18bc2b2f31d1aa60873c324c03a2dd2a" args="(ep, buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_udesc_set_buf0_addr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;udd_g_ep_table[ep*2].endpoint_pipe_address = buf</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adf40824e97da4c3c7cc651427bd2370c"></a><!-- doxytag: member="usbc_device.h::udd_udesc_set_buf0_autozlp" ref="adf40824e97da4c3c7cc651427bd2370c" args="(ep, val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_udesc_set_buf0_autozlp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.auto_zlp = val</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a33dbd2726ba58e81114c5a025548e479"></a><!-- doxytag: member="usbc_device.h::udd_udesc_set_buf0_ctn" ref="a33dbd2726ba58e81114c5a025548e479" args="(ep, size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_udesc_set_buf0_ctn</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.byte_count = size</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c3cec924aa661853b77c7bfa217f5f8"></a><!-- doxytag: member="usbc_device.h::udd_udesc_set_buf0_size" ref="a3c3cec924aa661853b77c7bfa217f5f8" args="(ep, size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_udesc_set_buf0_size</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.multi_packet_size = size</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa522e5e1d2f1d10c0e594b45cf7b8497"></a><!-- doxytag: member="usbc_device.h::udd_unforce_bank_interrupt" ref="aa522e5e1d2f1d10c0e594b45cf7b8497" args="(ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_unforce_bank_interrupt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(USBC_ARRAY(uesta0set,ep) = AVR32_USBC_UESTA0SET_NBUSYBKS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unforces all banks full (OUT) or free (IN) interrupt </p>

</div>
</div>
<a class="anchor" id="add60165f4e021c5e08c9b647e65496c8"></a><!-- doxytag: member="usbc_device.h::Usb_set_desc_tab_addr_reg" ref="add60165f4e021c5e08c9b647e65496c8" args="(addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Usb_set_desc_tab_addr_reg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;(Wr_bitfield(AVR32_USBC.udesc, AVR32_USBC_UDESC_MASK, addr))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a944621405e4cada2a5758a20c890cc73"></a><!-- doxytag: member="usbc_device.h::USBC_ARRAY" ref="a944621405e4cada2a5758a20c890cc73" args="(reg, index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBC_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((&amp;AVR32_USBC.reg)[(index)])</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generic macro for USBC registers that can be arrayed </p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 19 2011 21:04:53 for OpenShoe by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
